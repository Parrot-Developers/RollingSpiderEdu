//File: rsedu_control.c
/*
* AUTHOR Fabian Riether
* CREATE DATE 2015/08/25
* PURPOSE This module takes care of fully controlling the drone: Stabilizing based on sensor measurements, crash handling. For this purpose, it also calls the simulink-model.
* SPECIAL NOTES
* ===============================
* Change History
* 2015/08/25 created
* ==================================
*/


//frameworkparameters
//-------------------
#ifndef RSEDU_PARAMS_H_
#include "rsedu_params.h"
#endif

//control
//-------------------
//#include "rsedu_control.h"		/* might be declared differently for existing other code on drone itself, therefore do not create that file yourself */
#include "HAL.h"
#include "DroneRS_Compensator.h"
#include "rtwtypes.h"
#include <math.h>
#include <inttypes.h>
#include <stddef.h>

//data logging
#include "builtin_typeid_types.h"
#include "multiword_types.h"
#include "rt_logging.h"
#define QUOTE1(name)                   #name
#define QUOTE(name)                    QUOTE1(name)              /* need to expand name */
#ifndef SAVEFILE
# define MATFILE2(file)                #file ".mat"
# define MATFILE1(file)                MATFILE2(file)
# define MATFILE                       MATFILE1(/data/edu/RSdata)
#else
# define MATFILE                       QUOTE(SAVEFILE)
#endif

//communication
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/fcntl.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <poll.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <fcntl.h>



//set 'default' enabled feature set if paramsEDU.dat not found. Note: those variables are extern (declared in framework.h and defined here)
//--------------------------
int FEAT_TIME 		= 0; 	//enable processing time logging; 1 save in and out times of functions in /tmp/edu/ptimes/pt_RS_x.txt
int FEAT_OF_ACTIVE 	= 1; 	//optical flow results are read by control code, input into SIMULINK model and used for velocity estimation
int FEAT_POSVIS_RUN	= 1; 	//enable image processing computations and input them into SIMULINK model to record results
int FEAT_POSVIS_USE = 0; 	//include vision results in position estimation
int FEAT_IMSAVE 	= 0;	//image loggin; 0 discard images, 1 save to file, 2 enable video stream;
int FEAT_NOLOOK 	= 0;	//0: use lookup table lookuptable.dat instead of computing of hsv conversion, thresholding, matching etc onboard
int FEAT_NOSAFETY 	= 0;	//1: drone is not automatically shut down when take off-surface is not level, z-axis-acceleration is positive or x-y-accelerations exceed 6m/s^2
							//(This setting is dangerous but allows for more acrobatic maneuvers)

//Flight time takeoff, calibration: Nr of Cycles
int onCycles 		= 4000; //20sec total
int calibCycles 	= 400;
int takeoffCycles	= 200;


//-------------------
//SIMULINK compensator block "Parameter definitions"
//-------------------
/*
 * Parameter definitions from the SIMULINK compensator block go here.
 * For this purpose, copy the corresponding lines from ert_main.c from the autogenerated code here (./PackEmbeddedCode does that!)
 */


static RT_MODEL_DroneRS_Compensator_T DroneRS_Compensator_M_;
static RT_MODEL_DroneRS_Compensator_T *const DroneRS_Compensator_M =
  &DroneRS_Compensator_M_;             /* Real-time model */
static P_DroneRS_Compensator_T DroneRS_Compensator_P = {
  {
    13840.8,

    { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0165195073635001, 0.0152648883285633,
      0.0215786550496705, 0.000652733165165932, 0.000721701528439517,
      0.000690781425279554 },

    { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05, 0.05, 0.05, 1.0, 1.0, 1.0 },

    { 0.09, -0.06, 0.337, -0.0095, -0.0075, 0.0015, 101270.95 },

    { 1.00596, 1.00383, 0.99454 },

    { 0.99861, 1.00644 },
    0.99997,
    1.225,
    12.01725,
    0.05,

    { 0.99407531114557246, 0.99618461293246863, 1.0054899752649467,
      1.0013919347893572, 0.99360120821906917, 1.0000300009000269 },
    0.44,
    0.005,

    { -99.0, 0.0, 0.0, -9.0 },
    0.0,
    0.1,
    0.05,
    -30.0,
    20.0
  },                                   /* Variable: quadEDT
                                        * Referenced by:
                                        *   '<S7>/prsToAlt_Gain'
                                        *   '<S10>/inversesIMU_Gain'
                                        *   '<S12>/SaturationSonar'
                                        *   '<S65>/opticalFlowToVelocity_Gain'
                                        *   '<S63>/Constant'
                                        */

  {
    4.0,
    9.81,
    1.184,
    1.5e-5,
    0.068,

    { 8.0299999999999987e-5, 1.1699999999999996e-5, 0.0, 1.1699999999999995e-5,
      8.03e-5, 0.0, 0.0, 0.0, 0.0001366 },
    -0.015875999999999998,
    0.0624,
    2.0,
    0.033,
    0.008,
    0.0,
    0.000375,
    0.0,
    0.0,
    1.0209375000000001e-7,
    0.0,
    6.0699375000000009e-5,
    2.0418750000000001e-7,
    0.0107,
    0.00078263752785053692,
    0.15433206602850458,
    0.11868238913561441,
    0.25481807079117214,
    -0.13613568165555773,
    0.15271630954950383,
    10000.0,
    5.5,
    0.0034211943997592849,
    0.605147136,
    4.7199903669109095e-8,
    1.1392838555498841e-10,
    0
  },                                   /* Variable: quad
                                        * Referenced by: '<S2>/w0'
                                        */

  {
    { 0.28212412246252067, 1.272539291716861, 2.4208439774454473,
      2.4208439774454487, 1.272539291716863, 0.28212412246252133 },

    { 1.0, 2.2287149173647665, 2.5244618916938606, 1.5772531712757014,
      0.541022406829817, 0.079562396085500781 },

    { 0.007509257528603033, -0.022498139897706472, 0.014988905760749172,
      0.014988905760749172, -0.022498139897706455, 0.0075092575286030234 },

    { 1.0, -4.89810443312637, 9.5974881329446688, -9.4036722433820046,
      4.60730099744654, -0.90301240709954322 },
    0.3,
    0.8,
    0.4
  },                                   /* Variable: altEstim
                                        * Referenced by:
                                        *   '<S7>/Bias'
                                        *   '<S7>/Bias1'
                                        *   '<S10>/IIRgyroz'
                                        *   '<S12>/IIRprs'
                                        *   '<S12>/IIRsonar'
                                        *   '<S61>/Constant'
                                        *   '<S62>/Constant'
                                        *   '<S64>/Constant'
                                        *   '<S69>/IIRgyroz'
                                        */

  {
    0.6,
    7.0,
    0.5,
    80.0,
    -0.4,
    5.0
  },                                   /* Variable: ofhandle
                                        * Referenced by:
                                        *   '<S117>/Constant'
                                        *   '<S118>/Constant'
                                        *   '<S119>/Constant'
                                        *   '<S120>/Constant'
                                        *   '<S121>/Constant'
                                        *   '<S122>/Constant'
                                        *   '<S123>/Constant'
                                        *   '<S124>/Constant'
                                        *   '<S125>/Constant'
                                        *   '<S126>/Constant'
                                        *   '<S127>/Constant'
                                        */

  {
    0.18,
    0.5
  },                                   /* Variable: vishandle
                                        * Referenced by:
                                        *   '<S178>/Constant'
                                        *   '<S179>/Constant'
                                        *   '<S180>/Constant'
                                        */
  0.005,                               /* Variable: sampleTime_qcsim
                                        * Referenced by: '<S3>/sampleTime'
                                        */

  /* Start of '<Root>/DroneRS_Compensator' */
  {
    0.0,                               /* Mask Parameter: DiscreteDerivative_ICPrevScaled
                                        * Referenced by: '<S116>/UD'
                                        */
    -99.0,                             /* Mask Parameter: checkPosavailable_const
                                        * Referenced by: '<S177>/Constant'
                                        */
    -99.0,                             /* Mask Parameter: CompareToConstant_const
                                        * Referenced by: '<S181>/Constant'
                                        */
    0.0,                               /* Mask Parameter: outlierBelowFloor_const
                                        * Referenced by: '<S15>/Constant'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S10>/FIRaccelero'
                                        */

    /*  Expression: controlParams.filter_accelero.Coefficients
     * Referenced by: '<S10>/FIRaccelero'
     */
    { 0.026407724923238066, 0.14053136276241623, 0.3330609123143457,
      0.3330609123143457, 0.14053136276241623, 0.026407724923238066 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S10>/IIRgyroz'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S66>/Delay'
                                        */

    /*  Expression: pInitialization.M
     * Referenced by: '<S131>/KalmanGainM'
     */
    { 0.005756860081440762, 0.0, 0.0, 0.005756860081440762 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S69>/IIRgyroz'
                                        */
    200.0,                             /* Computed Parameter: TSamp_WtEt
                                        * Referenced by: '<S116>/TSamp'
                                        */
    -1.0,                              /* Expression: -1
                                        * Referenced by: '<S7>/invertzaxisGain'
                                        */
    0.0,                               /* Expression: -inf
                                        * Referenced by: '<S12>/SaturationSonar'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S7>/Delay2'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S12>/IIRprs'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S12>/IIRsonar'
                                        */

    /*  Expression: pInitialization.M
     * Referenced by: '<S16>/KalmanGainM'
     */
    { 0.026241420641871072, 0.069776736071495274 },

    /*  Expression: [0 0 quad.g]
     * Referenced by: '<S7>/gravity'
     */
    { 0.0, 0.0, 9.81 },

    /*  Expression: pInitialization.C
     * Referenced by: '<S11>/C'
     */
    { 1.0, 0.0 },
    0.0,                               /* Expression: pInitialization.D
                                        * Referenced by: '<S11>/D'
                                        */

    /*  Expression: pInitialization.X0
     * Referenced by: '<S11>/X0'
     */
    { -0.046, 0.0 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S65>/Delay'
                                        */

    /*  Expression: pInitialization.M
     * Referenced by: '<S71>/KalmanGainM'
     */
    { 0.1254656089860898, 0.0, 0.0, 0.1254656089860898 },

    /*  Expression: [0 0 -quad.g]
     * Referenced by: '<S67>/gravity'
     */
    { 0.0, 0.0, -9.81 },
    0.2,                               /* Expression: 0.2
                                        * Referenced by: '<S67>/gainaccinput'
                                        */

    /*  Expression: pInitialization.C
     * Referenced by: '<S68>/C'
     */
    { 1.0, 0.0, 0.0, 1.0 },

    /*  Expression: pInitialization.D
     * Referenced by: '<S68>/D'
     */
    { 0.0, 0.0, 0.0, 0.0 },

    /*  Expression: pInitialization.X0
     * Referenced by: '<S68>/X0'
     */
    { 0.0, 0.0 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S3>/Delay1'
                                        */

    /*  Expression: pInitialization.C
     * Referenced by: '<S128>/C'
     */
    { 1.0, 0.0, 0.0, 1.0 },

    /*  Expression: pInitialization.D
     * Referenced by: '<S128>/D'
     */
    { 0.0, 0.0, 0.0, 0.0 },

    /*  Expression: pInitialization.X0
     * Referenced by: '<S128>/X0'
     */
    { 0.1, 0.0 },
    0.005,                             /* Computed Parameter: SimplyIntegrateVelocity_gainval
                                        * Referenced by: '<S66>/SimplyIntegrateVelocity'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S66>/SimplyIntegrateVelocity'
                                        */
    2.0,                               /* Expression: 2
                                        * Referenced by: '<S66>/SimplyIntegrateVelocity'
                                        */
    -2.0,                              /* Expression: -2
                                        * Referenced by: '<S66>/SimplyIntegrateVelocity'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S66>/UseIPPosSwitch'
                                        */

    /*  Expression: pInitialization.A
     * Referenced by: '<S11>/A'
     */
    { 1.0, 0.0, 0.005, 1.0 },

    /*  Expression: pInitialization.B
     * Referenced by: '<S11>/B'
     */
    { 0.0, 0.005 },

    /*  Expression: pInitialization.L
     * Referenced by: '<S16>/KalmanGainL'
     */
    { 0.026590304322228548, 0.069776736071495274 },

    /*  Expression: pInitialization.A
     * Referenced by: '<S68>/A'
     */
    { 1.0, 0.0, 0.0, 1.0 },

    /*  Expression: pInitialization.B
     * Referenced by: '<S68>/B'
     */
    { 0.005, 0.0, 0.0, 0.005 },

    /*  Expression: pInitialization.L
     * Referenced by: '<S71>/KalmanGainL'
     */
    { 0.1254656089860898, 0.0, 0.0, 0.1254656089860898 },

    /*  Expression: pInitialization.A
     * Referenced by: '<S128>/A'
     */
    { 1.0, 0.0, 0.0, 1.0 },

    /*  Expression: pInitialization.B
     * Referenced by: '<S128>/B'
     */
    { 0.005, 0.0, 0.0, 0.005 },

    /*  Expression: pInitialization.L
     * Referenced by: '<S131>/KalmanGainL'
     */
    { 0.005756860081440762, 0.0, 0.0, 0.005756860081440762 },
    1U,                                /* Computed Parameter: Delay_DelayLength
                                        * Referenced by: '<S66>/Delay'
                                        */
    1U,                                /* Computed Parameter: Delay2_DelayLength
                                        * Referenced by: '<S7>/Delay2'
                                        */
    1U,                                /* Computed Parameter: MemoryX_DelayLength
                                        * Referenced by: '<S11>/MemoryX'
                                        */
    1U,                                /* Computed Parameter: Delay_DelayLength_g
                                        * Referenced by: '<S65>/Delay'
                                        */
    1U,                                /* Computed Parameter: MemoryX_DelayLength_g
                                        * Referenced by: '<S68>/MemoryX'
                                        */
    1U,                                /* Computed Parameter: Delay1_DelayLength
                                        * Referenced by: '<S3>/Delay1'
                                        */
    1U,                                /* Computed Parameter: MemoryX_DelayLength_m
                                        * Referenced by: '<S128>/MemoryX'
                                        */

    /* Start of '<S1>/ControllerPID2W' */
    {
      350.0,                           /* Expression: 350
                                        * Referenced by: '<S2>/D_z'
                                        */
      600.0,                           /* Expression: 600
                                        * Referenced by: '<S2>/P_z'
                                        */
      0.05,                            /* Expression: 0.05
                                        * Referenced by: '<S2>/takeoff_Gain'
                                        */

      /*  Expression: [0.08, -0.09]
       * Referenced by: '<S2>/D_xy'
       */
      { 0.08, -0.09 },

      /*  Expression: [-0.32,0.29]
       * Referenced by: '<S2>/P_xy'
       */
      { -0.32, 0.29 },
      0.0,                             /* Expression: 0
                                        * Referenced by: '<S2>/TakeoffOrControl_Switch'
                                        */
      0.0,                             /* Expression: 0
                                        * Referenced by: '<S2>/Delay'
                                        */
      0.001,                           /* Expression: 0.001
                                        * Referenced by: '<S2>/antiWU_Gain'
                                        */

      /*  Expression: [0.7071, 0.7071, -1.0000, -1.00;   -0.7071,    0.7071,   -1.0000,    1.00;   -0.7071,   -0.7071,   -1.0000,   -1.00;    0.7071,   -0.7071,   -1.0000,    1.00]
       * Referenced by: '<S4>/Action2omega'
       */
      { 0.7071, -0.7071, -0.7071, 0.7071, 0.7071, 0.7071, -0.7071, -0.7071, -1.0,
        -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0 },

      /*  Expression: [600;1300]
       * Referenced by: '<S2>/P_pr'
       */
      { 600.0, 1300.0 },
      0.005,                           /* Computed Parameter: DiscreteTimeIntegrator_gainval
                                        * Referenced by: '<S2>/Discrete-Time Integrator'
                                        */
      0.0,                             /* Expression: 0
                                        * Referenced by: '<S2>/Discrete-Time Integrator'
                                        */
      2.0,                             /* Expression: 2
                                        * Referenced by: '<S2>/Discrete-Time Integrator'
                                        */
      -2.0,                            /* Expression: -2
                                        * Referenced by: '<S2>/Discrete-Time Integrator'
                                        */
      200.0,                           /* Expression: 200
                                        * Referenced by: '<S2>/I_pr'
                                        */

      /*  Expression: [80;300]
       * Referenced by: '<S2>/D_pr'
       */
      { 80.0, 300.0 },
      6000.0,                          /* Expression: 6000
                                        * Referenced by: '<S2>/P_yaw'
                                        */
      1800.0,                          /* Expression: 0.3*6000
                                        * Referenced by: '<S2>/D_yaw'
                                        */
      2408.56,                         /* Expression: 0.92*2618
                                        * Referenced by: '<S2>/SaturationThrust'
                                        */
      -2408.56,                        /* Expression: -0.92*2618
                                        * Referenced by: '<S2>/SaturationThrust'
                                        */
      -1.0,                            /* Expression: -1
                                        * Referenced by: '<S4>/Gain3'
                                        */
      2618.0,                          /* Expression: 2618
                                        * Referenced by: '<S4>/Saturation1'
                                        */
      500.0,                           /* Expression: 500
                                        * Referenced by: '<S4>/Saturation1'
                                        */
      -1.0,                            /* Expression: -1
                                        * Referenced by: '<S4>/Gain4'
                                        */
      -1.0,                            /* Expression: -1
                                        * Referenced by: '<S4>/Gain5'
                                        */
      2618.0,                          /* Expression: 2618
                                        * Referenced by: '<S4>/Saturation4'
                                        */
      500.0,                           /* Expression: 500
                                        * Referenced by: '<S4>/Saturation4'
                                        */
      -1.0,                            /* Expression: -1
                                        * Referenced by: '<S4>/Gain6'
                                        */
      2618.0,                          /* Expression: 2618
                                        * Referenced by: '<S4>/Saturation2'
                                        */
      500.0,                           /* Expression: 500
                                        * Referenced by: '<S4>/Saturation2'
                                        */
      2618.0,                          /* Expression: 2618
                                        * Referenced by: '<S4>/Saturation3'
                                        */
      500.0,                           /* Expression: 500
                                        * Referenced by: '<S4>/Saturation3'
                                        */
      0.0085,                          /* Expression: 0.0085
                                        * Referenced by: '<S6>/w2MotorsQF_Gain'
                                        */
      1U                               /* Computed Parameter: Delay_DelayLength
                                        * Referenced by: '<S2>/Delay'
                                        */
    }
    /* End of '<S1>/ControllerPID2W' */
  }
  /* End of '<Root>/DroneRS_Compensator' */
};                                     /* Modifiable parameters */

//-------------------
// END OF SIMULINK compensator block "Parameter definitions"
//-------------------


//-------------------
//SIMULINK compensator block "Input/Outputport Declarations" IO(1/3)
//-------------------
/*
 * Input/output port declarations from the SIMULINK compensator block go here.
 * If those were changed, copy the corresponding lines from ert_main.c from the autogenerated code here.
 * Note, that for updating input/output-ports there are code paragraphs to update: IO(1/3), IO(2/3), IO(3/3)
 */

static B_DroneRS_Compensator_T DroneRS_Compensator_B;/* Observable signals */
static DW_DroneRS_Compensator_T DroneRS_Compensator_DW;/* Observable states */

/* '<Root>/controlModePosVSAtt_flagin' */
static boolean_T DroneRS_Compensator_U_controlModePosVSAtt_flagin;

/* '<Root>/pos_refin' */
static real_T DroneRS_Compensator_U_pos_refin[3];

/* '<Root>/attRS_refin' */
static real_T DroneRS_Compensator_U_attRS_refin[3];

/* '<Root>/ddx' */
static real_T DroneRS_Compensator_U_ddx;

/* '<Root>/ddy' */
static real_T DroneRS_Compensator_U_ddy;

/* '<Root>/ddz' */
static real_T DroneRS_Compensator_U_ddz;

/* '<Root>/p' */
static real_T DroneRS_Compensator_U_p;

/* '<Root>/q' */
static real_T DroneRS_Compensator_U_q;

/* '<Root>/r' */
static real_T DroneRS_Compensator_U_r;

/* '<Root>/altitude_sonar' */
static real_T DroneRS_Compensator_U_altitude_sonar;

/* '<Root>/prs' */
static real_T DroneRS_Compensator_U_prs;

/* '<Root>/opticalFlowRS_datin' */
static real_T DroneRS_Compensator_U_opticalFlowRS_datin[3];

/* '<Root>/sensordatabiasRS_datin' */
static real_T DroneRS_Compensator_U_sensordatabiasRS_datin[7];

/* '<Root>/posVIS_datin' */
static real_T DroneRS_Compensator_U_posVIS_datin[4];

/* '<Root>/usePosVIS_flagin' */
static real_T DroneRS_Compensator_U_usePosVIS_flagin;

/* '<Root>/batteryStatus_datin' */
static real_T DroneRS_Compensator_U_batteryStatus_datin[2];

/* '<Root>/motorsRS_cmdout' */
static real_T DroneRS_Compensator_Y_motorsRS_cmdout[4];

/* '<Root>/X' */
static real_T DroneRS_Compensator_Y_X;

/* '<Root>/Y' */
static real_T DroneRS_Compensator_Y_Y;

/* '<Root>/Z' */
static real_T DroneRS_Compensator_Y_Z;

/* '<Root>/yaw' */
static real_T DroneRS_Compensator_Y_yaw;

/* '<Root>/pitch' */
static real_T DroneRS_Compensator_Y_pitch;

/* '<Root>/roll' */
static real_T DroneRS_Compensator_Y_roll;

/* '<Root>/dx' */
static real_T DroneRS_Compensator_Y_dx;

/* '<Root>/dy' */
static real_T DroneRS_Compensator_Y_dy;

/* '<Root>/dz' */
static real_T DroneRS_Compensator_Y_dz;

/* '<Root>/pb' */
static real_T DroneRS_Compensator_Y_pb;

/* '<Root>/qb' */
static real_T DroneRS_Compensator_Y_qb;

/* '<Root>/rb' */
static real_T DroneRS_Compensator_Y_rb;

/* '<Root>/controlModePosVSAtt_flagout' */
static boolean_T DroneRS_Compensator_Y_controlModePosVSAtt_flagout;

/* '<Root>/poseRS_refout' */
static real_T DroneRS_Compensator_Y_poseRS_refout[6];

/* '<Root>/ddxb' */
static real_T DroneRS_Compensator_Y_ddxb;

/* '<Root>/ddyb' */
static real_T DroneRS_Compensator_Y_ddyb;

/* '<Root>/ddzb' */
static real_T DroneRS_Compensator_Y_ddzb;

/* '<Root>/pa' */
static real_T DroneRS_Compensator_Y_pa;

/* '<Root>/qa' */
static real_T DroneRS_Compensator_Y_qa;

/* '<Root>/ra' */
static real_T DroneRS_Compensator_Y_ra;

/* '<Root>/altitude_sonarb' */
static real_T DroneRS_Compensator_Y_altitude_sonarb;

/* '<Root>/prsb' */
static real_T DroneRS_Compensator_Y_prsb;

/* '<Root>/opticalFlowRS_datout' */
static real_T DroneRS_Compensator_Y_opticalFlowRS_datout[3];

/* '<Root>/sensordatabiasRS_datout' */
static real_T DroneRS_Compensator_Y_sensordatabiasRS_datout[7];

/* '<Root>/posVIS_datout' */
static real_T DroneRS_Compensator_Y_posVIS_datout[4];

/* '<Root>/usePosVIS_flagout' */
static real_T DroneRS_Compensator_Y_usePosVIS_flagout;

/* '<Root>/batteryStatus_datout' */
static real_T DroneRS_Compensator_Y_batteryStatus_datout[2];

//-------------------
//END OF SIMULINK compensator block "Input/Outputport Declarations" IO(1/3)
//-------------------

//steps the SIMULINK compensator block model one step
void rt_OneStep(RT_MODEL_DroneRS_Compensator_T *const DroneRS_Compensator_M);
void rt_OneStep(RT_MODEL_DroneRS_Compensator_T *const DroneRS_Compensator_M)
{
  static boolean_T OverrunFlag = false;

  /* Disable interrupts here */

  /* Check for overrun */
  if (OverrunFlag) {
	    rtmSetErrorStatus(DroneRS_Compensator_M, "Overrun");
    return;
  }

  OverrunFlag = true;

  /* Save FPU context here (if necessary) */
  /* Re-enable timer or interrupt here */
  /* Set model inputs here */

  /* Step the model */
  // (IO(2/3): If input-output-ports of the SIMULINK controller block changed, update these lines with the corresponding lines from ert_main.c)
  /* Step the model */
  DroneRS_Compensator_step(DroneRS_Compensator_M,
    DroneRS_Compensator_U_controlModePosVSAtt_flagin,
    DroneRS_Compensator_U_pos_refin, DroneRS_Compensator_U_attRS_refin,
    DroneRS_Compensator_U_ddx, DroneRS_Compensator_U_ddy,
    DroneRS_Compensator_U_ddz, DroneRS_Compensator_U_p, DroneRS_Compensator_U_q,
    DroneRS_Compensator_U_r, DroneRS_Compensator_U_altitude_sonar,
    DroneRS_Compensator_U_prs, DroneRS_Compensator_U_opticalFlowRS_datin,
    DroneRS_Compensator_U_sensordatabiasRS_datin,
    DroneRS_Compensator_U_posVIS_datin, DroneRS_Compensator_U_usePosVIS_flagin,
    DroneRS_Compensator_U_batteryStatus_datin,
    DroneRS_Compensator_Y_motorsRS_cmdout, &DroneRS_Compensator_Y_X,
    &DroneRS_Compensator_Y_Y, &DroneRS_Compensator_Y_Z,
    &DroneRS_Compensator_Y_yaw, &DroneRS_Compensator_Y_pitch,
    &DroneRS_Compensator_Y_roll, &DroneRS_Compensator_Y_dx,
    &DroneRS_Compensator_Y_dy, &DroneRS_Compensator_Y_dz,
    &DroneRS_Compensator_Y_pb, &DroneRS_Compensator_Y_qb,
    &DroneRS_Compensator_Y_rb,
    &DroneRS_Compensator_Y_controlModePosVSAtt_flagout,
    DroneRS_Compensator_Y_poseRS_refout, &DroneRS_Compensator_Y_ddxb,
    &DroneRS_Compensator_Y_ddyb, &DroneRS_Compensator_Y_ddzb,
    &DroneRS_Compensator_Y_pa, &DroneRS_Compensator_Y_qa,
    &DroneRS_Compensator_Y_ra, &DroneRS_Compensator_Y_altitude_sonarb,
    &DroneRS_Compensator_Y_prsb, DroneRS_Compensator_Y_opticalFlowRS_datout,
    DroneRS_Compensator_Y_sensordatabiasRS_datout,
    DroneRS_Compensator_Y_posVIS_datout,
    &DroneRS_Compensator_Y_usePosVIS_flagout,
    DroneRS_Compensator_Y_batteryStatus_datout);
  //-------------------
  //-------------------


  /* Get model outputs here */

  /* Indicate task complete */
  OverrunFlag = false;

  /* Disable interrupts here */
  /* Restore FPU context here (if necessary) */
  /* Enable interrupts here */
}


//--------------------
// RSEDU_control
//--------------------
/*
 * The function RSEDU_control is called at 200Hz to generate reference motor commands based on sensor values
 * @input hal_sensors_data Structure containing sensors current values
 * @output hal_sensors_cmd Structure containing commands to send to motors and LEDs
 */
void RSEDU_control(HAL_acquisition_t* hal_sensors_data, HAL_command_t* hal_sensors_cmd)
{
		//flight phases
		static int run_flag = 1;

		//process control
		static int counter = 0;
		static int counter_noOF = 0;

		static float MAX_ACCELL 	= 6.0;
		static float MAX_DELTADXY 	= 1.5;
		static float MAX_RANGE 		= 10.0;
		static float MIN_BATTTAKEOFF 	= 50.0;
		static float MIN_BATT		= 30.0;
		static int MAX_noOF 		= 50; //maximum acceptable numbers of cycles without optical flow

		//user input
		int power_usrinpt;
		double powerGain = 0;
		static double powerGain_eparam = 0.1;


		//data handling
		static double sensorCal[7];
		static double battLevelAvg;
		float of_data[5];
		float vis_data[4];
		float ofDefined;
		float ofQuality;

		//communication
		static char serverIP[16];
		static int sockfd = 0;
		static char sendBuff[1024];
		static char recvBuff[100];
		static struct sockaddr_in serv_addr;

		int pitch_ref_buff, roll_ref_buff, yaw_ref_buff, alt_ref_buff;
		
		static int serverstatus;
		static int of_fifo, vis_fifo;



		/*-------------------------
		 * PROGRAM
		 -------------------------*/

		//ptiming - declare and start
		//------------
		long long start;
		static FILE *ptfile;
		ptimer_start(FEAT_TIME,counter,&(start));
		//------------


		// Create easier aliases

		HAL_acquisition_t* in = hal_sensors_data;
		HAL_command_t    * out = hal_sensors_cmd;
		
		//ABORT FLIGHT and exit if run_flag 0
		if (run_flag==0)
			{
			if (counter>calibCycles)
			{
				printf("Saving logged data after %i cycles... \n",counter);
				rt_StopDataLogging(MATFILE, DroneRS_Compensator_M->rtwLogInfo);
			}

			if (FEAT_OF_ACTIVE)
			{
				close(of_fifo);
			}

			if (FEAT_TIME) {close(ptfile);};


			printf("Saving logged data... DONE \n");
			printf("Good night! \n");
			out->motors_speed[0] = 0;
			out->motors_speed[1] = 0;
			out->motors_speed[2] = 0;
			out->motors_speed[3] = 0;
			out->command = BLDC_CMD_STOP;
			usleep(100);
			exit(0);
			}


		//Process Control
		counter++;


		//Flight Stages s 0-4
		//--------------

		//s0: Initialize (server connection, get user settings)

		if (counter==1)
		{
			printf("\nBattery output voltage: %5.2f V - %0d percents\n", in->HAL_vbat_SI.vbat_V,(int)in->HAL_vbat_SI.vbat_percentage);
			printf("used: %d, users: %d, gyrotemp %f, acctemp %f, presstmp %f \n",(int)in->used,(int)in->count_user,in->HAL_gyro_SI.temperature,in->HAL_acc_SI.temperature,in->HAL_pressure_SI.temperature);


			//read parameters

			 FILE *paramFile;
			 paramFile = fopen("/data/edu/params/paramsEDU.dat", "r");
			 if (paramFile == NULL)
			 {
				 printf("ParamsEDU.dat parameter file not found, using default! \n");
			 }

			 else
				 {
				 char tmpbuff[50];
				 char tmpstr1[16];
				 char tmpstr2[16];
				 while(!feof(paramFile))
					 {
						  if (fgets(tmpbuff,50,paramFile))
						  {
							  sscanf(tmpbuff, "%15s : %15[^;];", tmpstr1, tmpstr2);

							  if (!strcmp(tmpstr1,"FEAT_OF_ACTIVE")) 		{FEAT_OF_ACTIVE = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"FEAT_POSVIS_RUN"))  {FEAT_POSVIS_RUN = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"POWERGAIN"))  		{powerGain_eparam = atoi(tmpstr2)/100.0;}
							  else if (!strcmp(tmpstr1,"FEAT_POSVIS_USE"))  {FEAT_POSVIS_USE = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"FEAT_NOLOOK"))  	{FEAT_NOLOOK = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"FEAT_IMSAVE"))    	{FEAT_IMSAVE = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"FEAT_TIME"))    	{FEAT_TIME = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"FEAT_NOSAFETY"))   	{FEAT_NOSAFETY = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"IP"))    	 		{memcpy(serverIP,tmpstr2,sizeof(tmpstr2));};

						  }
					}
				 fclose(paramFile);
			 }

			 printf("\nSettings:\n -----\n FEAT_TIME: %d \n FEAT_OF_ACTIVE: %d \n FEAT_POSVIS_RUN: %d \n FEAT_POSVIS_USE: %d \n FEAT_NOLOOK: %d \n FEAT_IMSAVE: %d \n FEAT_NOSAFETY: %d \n -----\n",FEAT_TIME, FEAT_OF_ACTIVE,FEAT_POSVIS_RUN,FEAT_POSVIS_USE,FEAT_NOLOOK,FEAT_IMSAVE,FEAT_NOSAFETY);


			//ptiming - init file
			//------------
				ptimer_init(FEAT_TIME,__func__,&(ptfile),&(run_flag));
			//------------



			//init reference Server Communication
			//-----
			printf("Connecting to reference value server... \n");

			if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
			{
			    printf("\n ERROR : Could not create socket \n");
			    exit(0);
			}

			memset(&serv_addr, '0', sizeof(serv_addr));

			serv_addr.sin_family = AF_INET;
			serv_addr.sin_port = htons(12345);

			if(inet_pton(AF_INET, serverIP, &serv_addr.sin_addr)<=0)
			{
			    printf("ERROR inet_pton error occured (connection to reference value server) \n");
			    exit(0);
			}

			if( connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
			{
			   printf("ERROR Connection to reference value server failed \n");
			   serverstatus = 1;
			   exit(0);
			}
			else
			{
				printf("Connected to reference value server! \n");
			}



			//Powergain user prompt
			//-----
			/*
			printf("Power-Gain in %% ? \n");
			scanf("%i", &power_usrinpt);
			powerGain_eparam = power_usrinpt/100.0;
			if (powerGain_eparam>1.0) {powerGain_eparam=1.0;};
			printf ("Power-Gain %f \n",powerGain_eparam);
			*/

		}

		//Initialize inter-thread communication
		else if (counter == 2)
		{

			//Initialize communication with optical flow thread
			//-------
			printf("Waiting for optical flow connection...\n");
			usleep(100);
			of_fifo = open("/tmp/of_fifo",O_RDONLY); //O_NONBLOCK O_RDONLY
			fcntl(of_fifo, F_SETFL, fcntl(of_fifo, F_GETFL) | O_NONBLOCK);

			if (FEAT_OF_ACTIVE)
			{
				read(of_fifo,(float*)(&of_data),sizeof(of_data));
				if (of_fifo<0)
				{
					printf("WARNING optical flow might not be running, %d!\n\n",of_fifo);
				}
				else
				{
					printf("Got optical flow connection, %d!\n",of_fifo);
				}

			}
			else
			{
				printf("Optical Flow deactivated! \n");
			}


			//Initialize communication with image processing thread
			//-------
			printf("Waiting for image processing connection...\n");
			usleep(100);
			vis_fifo = open("/tmp/vis_fifo",O_RDONLY); //O_NONBLOCK O_RDONLY
			fcntl(vis_fifo, F_SETFL, fcntl(vis_fifo, F_GETFL) | O_NONBLOCK);

			if (FEAT_POSVIS_RUN)
			{
				read(vis_fifo,(float*)(&vis_data),sizeof(vis_data));
				if (vis_fifo<0)
				{
					printf("WARNING image processing might not be running, %d!\n",vis_fifo);
				}
				else
				{
					printf("Got image processing connection, %d !\n",vis_fifo);
				}
			}
			else
			{
				printf("POSVIS computations deactivated! \n");
			};


			//init sensor calibration measurements
			//-----
			sensorCal[0] = in->HAL_acc_SI.x;
			sensorCal[1] = in->HAL_acc_SI.y;
			sensorCal[2] = in->HAL_acc_SI.z;
			sensorCal[3] = in->HAL_gyro_SI.x;
			sensorCal[4] = in->HAL_gyro_SI.y;
			sensorCal[5] = in->HAL_gyro_SI.z;
			sensorCal[6] = in->HAL_pressure_SI.pressure;

			battLevelAvg = (double)((int)in->HAL_vbat_SI.vbat_percentage);

			//Activate motors
			out->command = BLDC_CMD_START;
		}


		//s1: Record calibration data
		else if (counter < calibCycles)
		{
			sensorCal[0] = sensorCal[0]*(counter-1)/counter + in->HAL_acc_SI.x/counter;
			sensorCal[1] = sensorCal[1]*(counter-1)/counter + in->HAL_acc_SI.y/counter;
			sensorCal[2] = sensorCal[2]*(counter-1)/counter + in->HAL_acc_SI.z/counter;
			sensorCal[3] = sensorCal[3]*(counter-1)/counter + in->HAL_gyro_SI.x/counter;
			sensorCal[4] = sensorCal[4]*(counter-1)/counter + in->HAL_gyro_SI.y/counter;
			sensorCal[5] = sensorCal[5]*(counter-1)/counter + in->HAL_gyro_SI.z/counter;
			sensorCal[6] = sensorCal[6]*(counter-1)/counter + in->HAL_pressure_SI.pressure/counter;

			battLevelAvg = battLevelAvg*(counter-1)/counter + (double)((int)in->HAL_vbat_SI.vbat_percentage)/counter;

			//keep fifos empty
			if (FEAT_OF_ACTIVE)  read(of_fifo,(float*)(&of_data),sizeof(of_data));
			if (FEAT_POSVIS_RUN) read(vis_fifo,(float*)(&vis_data),sizeof(vis_data));


			//Power motors with 0 velocity
			out->motors_speed[0] = 0;
			out->motors_speed[1] = 0;
			out->motors_speed[2] = 0;
			out->motors_speed[3] = 0;
			out->command = BLDC_CMD_STOP;
			return;
		}
		
		//s2: Initialize dynamic model for control
		else if (counter==calibCycles)
			{
			printf("Batterylevel: %f\n",battLevelAvg);
			printf("Sensorcal: %f :: %f :: %f :: %f :: %f :: %f :: %f \n",sensorCal[0],sensorCal[1],9.81+sensorCal[2],sensorCal[3],sensorCal[4],sensorCal[5],sensorCal[6]);

			//Stop if angled take-off
			if ( (!FEAT_NOSAFETY) && abs(9.81+sensorCal[2]) > 0.7)
			{
				run_flag = 0;
				printf("ERROR: Please take off from a level surface! \n");
				out->motors_speed[0] = 0;
				out->motors_speed[1] = 0;
				out->motors_speed[2] = 0;
				out->motors_speed[3] = 0;
				out->command = BLDC_CMD_STOP;
				return;
			}



			//Init SIMULINK compensator model
			//(IO(3/3): If input-output-ports of the SIMULINK controller block changed, update these lines with the corresponding lines from ert_main.c)
			//----------

			  /* Pack model data into RTM */
			  DroneRS_Compensator_M->ModelData.defaultParam = &DroneRS_Compensator_P;
			  DroneRS_Compensator_M->ModelData.blockIO = &DroneRS_Compensator_B;
			  DroneRS_Compensator_M->ModelData.dwork = &DroneRS_Compensator_DW;

			  /* Initialize model */
			  DroneRS_Compensator_initialize(DroneRS_Compensator_M,
			    &DroneRS_Compensator_U_controlModePosVSAtt_flagin,
			    DroneRS_Compensator_U_pos_refin, DroneRS_Compensator_U_attRS_refin,
			    &DroneRS_Compensator_U_ddx, &DroneRS_Compensator_U_ddy,
			    &DroneRS_Compensator_U_ddz, &DroneRS_Compensator_U_p,
			    &DroneRS_Compensator_U_q, &DroneRS_Compensator_U_r,
			    &DroneRS_Compensator_U_altitude_sonar, &DroneRS_Compensator_U_prs,
			    DroneRS_Compensator_U_opticalFlowRS_datin,
			    DroneRS_Compensator_U_sensordatabiasRS_datin,
			    DroneRS_Compensator_U_posVIS_datin, &DroneRS_Compensator_U_usePosVIS_flagin,
			    DroneRS_Compensator_U_batteryStatus_datin,
			    DroneRS_Compensator_Y_motorsRS_cmdout, &DroneRS_Compensator_Y_X,
			    &DroneRS_Compensator_Y_Y, &DroneRS_Compensator_Y_Z,
			    &DroneRS_Compensator_Y_yaw, &DroneRS_Compensator_Y_pitch,
			    &DroneRS_Compensator_Y_roll, &DroneRS_Compensator_Y_dx,
			    &DroneRS_Compensator_Y_dy, &DroneRS_Compensator_Y_dz,
			    &DroneRS_Compensator_Y_pb, &DroneRS_Compensator_Y_qb,
			    &DroneRS_Compensator_Y_rb,
			    &DroneRS_Compensator_Y_controlModePosVSAtt_flagout,
			    DroneRS_Compensator_Y_poseRS_refout, &DroneRS_Compensator_Y_ddxb,
			    &DroneRS_Compensator_Y_ddyb, &DroneRS_Compensator_Y_ddzb,
			    &DroneRS_Compensator_Y_pa, &DroneRS_Compensator_Y_qa,
			    &DroneRS_Compensator_Y_ra, &DroneRS_Compensator_Y_altitude_sonarb,
			    &DroneRS_Compensator_Y_prsb, DroneRS_Compensator_Y_opticalFlowRS_datout,
			    DroneRS_Compensator_Y_sensordatabiasRS_datout,
			    DroneRS_Compensator_Y_posVIS_datout,
			    &DroneRS_Compensator_Y_usePosVIS_flagout,
			    DroneRS_Compensator_Y_batteryStatus_datout);

			  //-------------------
			  //-------------------

			//init optical flow and vision outputport in case that functionality is deactivated
			DroneRS_Compensator_U_posVIS_datin[0] = NO_VIS_X;
			DroneRS_Compensator_U_posVIS_datin[1] = 0.0;
			DroneRS_Compensator_U_posVIS_datin[2] = 0.0;
			DroneRS_Compensator_U_posVIS_datin[3] = 0.0;

			//check if image processing up and running
			if ((FEAT_POSVIS_RUN) && (vis_fifo <0))
				{
				vis_fifo = open("/tmp/vis_fifo",O_RDONLY); //O_NONBLOCK O_RDONLY
				fcntl(vis_fifo, F_SETFL, fcntl(vis_fifo, F_GETFL) | O_NONBLOCK);
				if (vis_fifo<0) printf("WARNING image processing not connected!\n");
				}

			//check if optical flow up and running
			if ((FEAT_OF_ACTIVE) && (of_fifo <0))
				{
				of_fifo = open("/tmp/of_fifo",O_RDONLY); //O_NONBLOCK O_RDONLY
				fcntl(of_fifo, F_SETFL, fcntl(of_fifo, F_GETFL) | O_NONBLOCK);
				if (of_fifo<0) printf("ERROR optical flow not running!\n");
				run_flag = 0;
				}

			//input sensor biases into model
			DroneRS_Compensator_U_sensordatabiasRS_datin[0] = sensorCal[0];
			DroneRS_Compensator_U_sensordatabiasRS_datin[1] = sensorCal[1];
			DroneRS_Compensator_U_sensordatabiasRS_datin[2] = 9.81+sensorCal[2];
			DroneRS_Compensator_U_sensordatabiasRS_datin[3] = sensorCal[3];
			DroneRS_Compensator_U_sensordatabiasRS_datin[4] = sensorCal[4];
			DroneRS_Compensator_U_sensordatabiasRS_datin[5] = sensorCal[5];
			DroneRS_Compensator_U_sensordatabiasRS_datin[6] = sensorCal[6];

		   //Display beginning of relevant data output on screen
			//printf("Data_block_start\n");

		   //Power motors, velocity 0
  		    out->command = BLDC_CMD_RUN;

			}

		//s3: Fly
		else if (counter <= onCycles)
			{

			//Tune settings to flight mode
			//----------

			//3.1 take off-setting
			if (counter<calibCycles + takeoffCycles)
				{
				powerGain = powerGain_eparam;
				DroneRS_Compensator_U_pos_refin[2] = 1; //enables take-off procedure, disables altitude-control

			       //React to possible low battery
	  			    if ((DroneRS_Compensator_U_batteryStatus_datin[1]<MIN_BATTTAKEOFF) && (DroneRS_Compensator_U_batteryStatus_datin[1]>0.1))
	  			    {						
					run_flag = 0;
					printf("Flight aborted due to low voltage (%f %%): shutting down motors now, charge battery!\n",DroneRS_Compensator_U_batteryStatus_datin[1]);
					out->motors_speed[0] = 0;
					out->motors_speed[1] = 0;
					out->motors_speed[2] = 0;
					out->motors_speed[3] = 0;
					out->command = BLDC_CMD_STOP;
					return;
	  			    }
				}

			//3.2 transition to actual flight: enable altitude-control setting
			else if (counter == calibCycles + takeoffCycles)
			{
				DroneRS_Compensator_U_pos_refin[2] = -1.1;
			}
			//3.3 actual flight setting
			else if (counter<onCycles)
			{
				powerGain = powerGain_eparam;

				//Read from reference value server
				fcntl(sockfd, F_SETFL, O_NONBLOCK);
				memset(recvBuff, '\0', sizeof(recvBuff));
 			    recv(sockfd, recvBuff, sizeof(recvBuff),O_NONBLOCK);


  			    //Input to Model: reference values

  			    if ( (recvBuff[0])!='\0' )
  			    {
  			    	sscanf(recvBuff,"%i %i %i %i %i", &run_flag, &pitch_ref_buff,&roll_ref_buff,&yaw_ref_buff,&alt_ref_buff);
  			    	DroneRS_Compensator_U_attRS_refin[0] = (double)((yaw_ref_buff-10000)/1000.0);
  			    	DroneRS_Compensator_U_attRS_refin[1] = (double)((pitch_ref_buff-10000)/1000.0);
  			    	DroneRS_Compensator_U_attRS_refin[2] = (double)((roll_ref_buff -10000)/1000.0);
  			    	if ( ((double)(alt_ref_buff/100.0)) >= -4.0)
  			    		{
  			    		DroneRS_Compensator_U_pos_refin[2]    = (double)(alt_ref_buff/100.0);
  			    		}
  			    }

  			    if ((DroneRS_Compensator_U_attRS_refin[1]==0.0) && (DroneRS_Compensator_U_attRS_refin[2]==0.0))
  			    	//control position + velocity if no specific reference attitude given (yaw angle ok)
  			    	DroneRS_Compensator_U_controlModePosVSAtt_flagin = 1; //1 ; 1 position reference, 0 angle reference
  			    else
  			    	//angle control
  			    	DroneRS_Compensator_U_controlModePosVSAtt_flagin = 0; //0 ; 1 position reference, 0 angle reference


  			    //use of position estimate from vision
  			    DroneRS_Compensator_U_usePosVIS_flagin = FEAT_POSVIS_USE;

  			    //React to possible Flight abort request
  			    if (run_flag==0)
  			    {
					printf("Flight abort request: shutting down motors now\n");
					out->motors_speed[0] = 0;
					out->motors_speed[1] = 0;
					out->motors_speed[2] = 0;
					out->motors_speed[3] = 0;
					out->command = BLDC_CMD_STOP;
					return;
  			    }

			}

			//3.4 init to stop flight (because of end of flight duration)
			else
			{
				powerGain = 0;
			};




			//Actual flight control
			//---------------------

			//safety abort for high accelerations or position
			if (  ((!FEAT_NOSAFETY) && ((abs(in->HAL_acc_SI.x) > MAX_ACCELL) || (abs(in->HAL_acc_SI.y) > MAX_ACCELL) ||  (in->HAL_acc_SI.z>0) ) )
					||
				  (( FEAT_NOSAFETY) && ((abs(in->HAL_acc_SI.x) > MAX_ACCELL*3) || (abs(in->HAL_acc_SI.y) > MAX_ACCELL*3)  ) )
				    ||
				    ((abs(DroneRS_Compensator_Y_X) > MAX_RANGE) || (abs(DroneRS_Compensator_Y_Y) > MAX_RANGE))
				)
			{
					run_flag = 0;
					if (((abs(DroneRS_Compensator_Y_X) > MAX_RANGE) || (abs(DroneRS_Compensator_Y_Y) > MAX_RANGE))) printf("Drone out of range: shutting down motors now\n");
					else printf("Flight crash detected (accelerometer): shutting down motors now\n");

					out->motors_speed[0] = 0;
					out->motors_speed[1] = 0;
					out->motors_speed[2] = 0;
					out->motors_speed[3] = 0;
					out->command = BLDC_CMD_STOP;
					return;
			}
			//safety abort due to low battery in flight
			if ((DroneRS_Compensator_U_batteryStatus_datin[1]<MIN_BATT) && (DroneRS_Compensator_U_batteryStatus_datin[1]>1.0))
			{
					run_flag = 0;
					printf("Flight aborted due to low voltage (%f %%): shutting down motors now, charge battery!\n",DroneRS_Compensator_U_batteryStatus_datin[1]);
					out->motors_speed[0] = 0;
					out->motors_speed[1] = 0;
					out->motors_speed[2] = 0;
					out->motors_speed[3] = 0;
					out->command = BLDC_CMD_STOP;
					return;	
			};


			//Input to Model: optical flow computations (setup as zero-order hold: no updates on static var when nothing new in fifo)
			if((FEAT_OF_ACTIVE) && (of_fifo>0))
			{
					//usleep(100);
					//read(of_fifo,(float*)(&of_data),sizeof(of_data));
					//close(of_fifo);

					if ( (read(of_fifo,(float*)(&of_data),sizeof(of_data)) > 0) && ( (of_data[0]!=0.0) || (of_data[1]!=0.0) ))
					{
						ofQuality = of_data[3];
						ofDefined = of_data[4];
						if (ofQuality>0)
						{
							counter_noOF = 0;
							DroneRS_Compensator_U_opticalFlowRS_datin[0] = (double)of_data[0];
							DroneRS_Compensator_U_opticalFlowRS_datin[1] = (double)of_data[1];
							DroneRS_Compensator_U_opticalFlowRS_datin[2] = (double)of_data[2];
							//printf("of: %f %f %f \n",of_data[0],of_data[1],of_data[2]);
						}
					}
					else
					{
						if ( counter>(calibCycles + takeoffCycles) )
						{
							counter_noOF += 1;

							if (counter_noOF>=MAX_noOF)
													{	run_flag = 0;
														printf("Problem with optical flow, there has been no flow for %d cycles in cycle %d: shutting down motors now\n",counter_noOF,counter);
														out->motors_speed[0] = 0;
														out->motors_speed[1] = 0;
														out->motors_speed[2] = 0;
														out->motors_speed[3] = 0;
														out->command = BLDC_CMD_STOP;
														return;
													}
						}


					};

			}

			//safety abort for high mismatch OF vs state velocities
			if (
					(counter>(calibCycles + takeoffCycles))
					&&
					(
							( (abs(of_data[0])>0.01) &&  (abs(20*of_data[0] - DroneRS_Compensator_Y_dx ) > MAX_DELTADXY) )
						||  ( (abs(of_data[1])>0.01) &&  (abs(20*of_data[1] - DroneRS_Compensator_Y_dy ) > MAX_DELTADXY) )
					)

				)
			{
					run_flag = 0;
					printf("Flight crash about to happen, mismatch optical flow and state estimate %f %f : shutting down motors now\n",abs(20*of_data[0] - DroneRS_Compensator_Y_dx),abs(20*of_data[1] - DroneRS_Compensator_Y_dy));
					out->motors_speed[0] = 0;
					out->motors_speed[1] = 0;
					out->motors_speed[2] = 0;
					out->motors_speed[3] = 0;
					out->command = BLDC_CMD_STOP;
					return;
			}

			//Input to Model: image processing computations (DONOT setup as zero-order hold (pos_x -99.0 when no position available))
			if((FEAT_POSVIS_RUN) && (vis_fifo>0))
			{

					if ((read(vis_fifo,(float*)(&vis_data),sizeof(vis_data)) > 0) && ((vis_data[0]!=0.0) || (vis_data[1]) || (vis_data[3]) ) )
					{
						DroneRS_Compensator_U_posVIS_datin[0] = (double)vis_data[0];
						DroneRS_Compensator_U_posVIS_datin[1] = (double)vis_data[1];
						DroneRS_Compensator_U_posVIS_datin[2] = (double)vis_data[2];
						DroneRS_Compensator_U_posVIS_datin[3] = (double)vis_data[3];

					}
					else
					{
						DroneRS_Compensator_U_posVIS_datin[0] = NO_VIS_X;
						DroneRS_Compensator_U_posVIS_datin[1] = 0.0;
						DroneRS_Compensator_U_posVIS_datin[2] = 0.0;
						DroneRS_Compensator_U_posVIS_datin[3] = 0.0;
					}

			}

			//Input to Model: sensor signals
			DroneRS_Compensator_U_ddx 	= in->HAL_acc_SI.x;
			DroneRS_Compensator_U_ddy 	= in->HAL_acc_SI.y;
			DroneRS_Compensator_U_ddz 	= in->HAL_acc_SI.z;
			DroneRS_Compensator_U_p 	= in->HAL_gyro_SI.x;
			DroneRS_Compensator_U_q 	= in->HAL_gyro_SI.y;
			DroneRS_Compensator_U_r		= in->HAL_gyro_SI.z;
			DroneRS_Compensator_U_altitude_sonar	= in->HAL_ultrasound_SI.altitude;
			DroneRS_Compensator_U_prs 	= in->HAL_pressure_SI.pressure;

			DroneRS_Compensator_U_batteryStatus_datin[0] = in->HAL_vbat_SI.vbat_V;
			DroneRS_Compensator_U_batteryStatus_datin[1] = (double)((int)in->HAL_vbat_SI.vbat_percentage);

			// compute control commands
			if (rtmGetErrorStatus(DroneRS_Compensator_M) == (NULL)){
				rt_OneStep(DroneRS_Compensator_M);
			} else {
				run_flag = 0;
				printf("ERROR: Error from simulink model @ counter=%i !\n", counter);
				out->motors_speed[0] = 0;
				out->motors_speed[1] = 0;
				out->motors_speed[2] = 0;
				out->motors_speed[3] = 0;
				out->command = BLDC_CMD_STOP;
				return;
			}

			//power engines
			if (counter<onCycles)
				{
					out->command = BLDC_CMD_RUN;
				}
				else
				{
					out->command = BLDC_CMD_STOP;
					return;
				};


			// update motor commands with control commands
			out->motors_speed[0] =  (int)(powerGain*(abs(DroneRS_Compensator_Y_motorsRS_cmdout[0])));
			out->motors_speed[1] =  (int)(powerGain*(abs(DroneRS_Compensator_Y_motorsRS_cmdout[1])));
			out->motors_speed[2] =  (int)(powerGain*(abs(DroneRS_Compensator_Y_motorsRS_cmdout[2])));
			out->motors_speed[3] =  (int)(powerGain*(abs(DroneRS_Compensator_Y_motorsRS_cmdout[3])));
			usleep(100);
			//printf("motorcmd: %d\n",out->motors_speed[0]);

			}

		//s4.0 End flight: log data and close program

		else //counter=durTest+1
		{
			/* Matfile logging save*/
			printf("Saving logged data at end of flight... \n");
			rt_StopDataLogging(MATFILE, DroneRS_Compensator_M->rtwLogInfo);
			if (FEAT_OF_ACTIVE)
			{
				close(of_fifo);
			}
			printf("Saving logged data... DONE \n");

			if (FEAT_TIME) {fclose(ptfile);}


			exit(0);
		}


		usleep(200);


		//ptiming - store
		//----------
		ptimer_stopstore(FEAT_TIME,counter,start, ptfile);
		//----------

}
