//File: rsedu_control.c
/*
* AUTHOR Fabian Riether
* CREATE DATE 2015/08/25
* PURPOSE This module takes care of fully controlling the drone: Stabilizing based on sensor measurements, crash handling. For this purpose, it also calls the simulink-model.
* SPECIAL NOTES
* ===============================
* 2015/08/25 created
* ==================================
*/


#include "rsedu_control.h"
#include <stdbool.h>



//set 'default' enabled feature set if paramsEDU.dat not found. Note: those variables are extern (declared in framework.h and defined here)
//--------------------------
int FEAT_TIME 		= 0; 	//enable processing time logging; 1 save in and out times of functions in /tmp/edu/ptimes/pt_RS_x.txt
int FEAT_OF_ACTIVE 	= 1; 	//optical flow results are read by control code, input into SIMULINK model and used for velocity estimation
int FEAT_POSVIS_RUN	= 1; 	//enable image processing computations and input them into SIMULINK model to record results
int FEAT_POSVIS_USE 	= 0; 	//include vision results in position estimation
int FEAT_IMSAVE 	= 0;	//image loggin; 0 discard images, 1 save to file, 2 enable video stream;
int FEAT_NOLOOK 	= 0;	//0: use lookup table lookuptable.dat instead of computing of hsv conversion, thresholding, matching etc onboard
int FEAT_NOSAFETY 	= 0;	//1: drone is not automatically shut down when take off-surface is not level, z-axis-acceleration is positive or x-y-accelerations exceed 6m/s^2
//(This setting is dangerous but allows for more acrobatic maneuvers)

//Flight time takeoff, calibration: Nr of Cycles
int onCycles 		= 4000; //note that code runs at 200Hz! So 4000-> 20sec
int calibCycles 	= 400;
int takeoffCycles	= 200;


//-------------------
//SIMULINK compensator block "Parameter definitions"
//-------------------
/*
 * Parameter definitions from the SIMULINK compensator block go here.
 * For this purpose, copy the corresponding lines from ert_main.c from the autogenerated code here (./PackEmbeddedCode does that!)
 */


static RT_MODEL_Drone_Compensator_T Drone_Compensator_M_;
static RT_MODEL_Drone_Compensator_T *const Drone_Compensator_M =
  &Drone_Compensator_M_;               /* Real-time model */
static P_Drone_Compensator_T Drone_Compensator_P = {
  {
    4.7199903669109095e-8,
    500.0,
    13840.8,
    1530.72683064892,

    { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0165195073635001, 0.0152648883285633,
      0.0215786550496705, 0.000652733165165932, 0.000721701528439517,
      0.000690781425279554 },

    { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05, 0.05, 0.05, 1.0, 1.0, 1.0 },
    1.0,

    { 0.09, -0.06, -9.473, -0.0095, -0.0075, 0.0015, 101270.95 },

    { 1.00596, 1.00383, 0.99454 },

    { 0.99861, 1.00644, 0.99997 },
    1.225,
    12.01725,

    { 0.99407531114557246, 0.99618461293246863, 1.0054899752649467,
      1.0013919347893572, 0.99360120821906917, 1.0000300009000269 },
    0.44,

    {
      { 3.5, 70.0 },

      { -99.0, 0.0, 0.0, -9.0 },
      0.0
    },
    0.05,
    0.005,
    0.1,
    5.5,
    2.5,
    0.1,
    3.0,
    1.0,
    0.0,
    3.0,
    1.0,
    1.0,
    -1.1,
    -99.0,
    -9.0,
    10.0,
    0.05,
    0.0,
    0.0,
    -30.0,
    20.0,
    1.0
  },                                   /* Variable: quadEDT
                                        * Referenced by:
                                        *   '<S3>/sampleTime'
                                        *   '<S6>/thrustToMotorcommand'
                                        *   '<S6>/Saturation5'
                                        *   '<S7>/prsToAlt_gain'
                                        *   '<S10>/inverseIMU_gain'
                                        *   '<S12>/SaturationSonar'
                                        *   '<S184>/Constant'
                                        *   '<S61>/Constant'
                                        */

  {
    4.0,
    9.81,
    1.184,
    1.5e-5,
    0.068,

    { 6.86e-5, 0.0, 0.0, 0.0, 9.2e-5, 0.0, 0.0, 0.0, 0.0001366 },
    -0.015875999999999998,
    0.0624,
    2.0,
    0.033,
    0.008,
    0.0,
    0.000375,
    0.0,
    0.0,
    1.0209375000000001e-7,
    0.0,
    6.0699375000000009e-5,
    2.0418750000000001e-7,
    0.0107,
    0.00078263752785053692,
    0.15433206602850458,
    0.11868238913561441,
    0.25481807079117214,
    -0.13613568165555773,
    0.15271630954950383,
    10000.0,
    5.5,
    0.0034211943997592849,
    0.605147136,
    4.7199903669109095e-8,
    1.1392838555498841e-10,
    0
  },                                   /* Variable: quad
                                        * Referenced by:
                                        *   '<S2>/w0'
                                        *   '<S3>/sampleTime1'
                                        */

  {
    { 1.0, 0.0024137419083240857, -0.044123463146040563, -0.044123463146040563,
      1.0, -0.0024137419083240857, -0.044123463146040563, 0.044123463146040563,
      1.0, 0.0024137419083240857, 0.044123463146040563, 0.044123463146040563,
      1.0, -0.0024137419083240857, 0.044123463146040563, -0.044123463146040563 },

    { 0.25, 0.25, 0.25, 0.25, 103.57362530676717, -103.57362530676717,
      103.57362530676717, -103.57362530676717, -5.6659197210460537,
      -5.6659197210460546, 5.6659197210460546, 5.6659197210460546,
      -5.6659197210460546, 5.6659197210460546, 5.6659197210460546,
      -5.6659197210460546 },
    0.12,
    0.92,
    0.32664221335170257
  },                                   /* Variable: controlHelperParams
                                        * Referenced by:
                                        *   '<S2>/takeoff_gain'
                                        *   '<S2>/SaturationThrust'
                                        *   '<S4>/TorquetotalThrustToThrustperMotor'
                                        */

  /* Start of '<Root>/Drone_Compensator' */
  {
    0.0,                               /* Mask Parameter: DiscreteDerivative_ICPrevScaled
                                        * Referenced by: '<S119>/UD'
                                        */
    -99.0,                             /* Mask Parameter: checkifPosavailable_const
                                        * Referenced by: '<S180>/Constant'
                                        */
    0.18,                              /* Mask Parameter: maxp3_const
                                        * Referenced by: '<S181>/Constant'
                                        */
    0.18,                              /* Mask Parameter: maxq3_const
                                        * Referenced by: '<S182>/Constant'
                                        */
    1.0,                               /* Mask Parameter: planarjumpsVISPOS_const
                                        * Referenced by: '<S183>/Constant'
                                        */
    0.6,                               /* Mask Parameter: maxp_const
                                        * Referenced by: '<S122>/Constant'
                                        */
    0.6,                               /* Mask Parameter: maxq_const
                                        * Referenced by: '<S124>/Constant'
                                        */
    7.0,                               /* Mask Parameter: maxw1_const
                                        * Referenced by: '<S126>/Constant'
                                        */
    7.0,                               /* Mask Parameter: maxw2_const
                                        * Referenced by: '<S127>/Constant'
                                        */
    80.0,                              /* Mask Parameter: maxdw1_const
                                        * Referenced by: '<S120>/Constant'
                                        */
    80.0,                              /* Mask Parameter: maxdw2_const
                                        * Referenced by: '<S121>/Constant'
                                        */
    0.5,                               /* Mask Parameter: maxp2_const
                                        * Referenced by: '<S123>/Constant'
                                        */
    0.5,                               /* Mask Parameter: maxq2_const
                                        * Referenced by: '<S125>/Constant'
                                        */
    5.0,                               /* Mask Parameter: maxw3_const
                                        * Referenced by: '<S128>/Constant'
                                        */
    5.0,                               /* Mask Parameter: maxw4_const
                                        * Referenced by: '<S129>/Constant'
                                        */
    0.3,                               /* Mask Parameter: outlierJump_const
                                        * Referenced by: '<S64>/Constant'
                                        */
    0.8,                               /* Mask Parameter: currentEstimateVeryOffFromPress
                                        * Referenced by: '<S62>/Constant'
                                        */
    0.4,                               /* Mask Parameter: currentStateVeryOffsonarflt_con
                                        * Referenced by: '<S63>/Constant'
                                        */
    0.0,                               /* Mask Parameter: outlierBelowFloor_const
                                        * Referenced by: '<S13>/Constant'
                                        */
    -0.4,                              /* Mask Parameter: minHeightforOF_const
                                        * Referenced by: '<S130>/Constant'
                                        */
    0.0,                               /* Mask Parameter: donotuseaccifopticalflowneverav
                                        * Referenced by: '<S71>/Constant'
                                        */
    0.0,                               /* Mask Parameter: donotuseaccifopticalflownever_g
                                        * Referenced by: '<S72>/Constant'
                                        */
    -0.4,                              /* Mask Parameter: DeactivateAccelerationIfOFisnot
                                        * Referenced by: '<S70>/Constant'
                                        */

    /*  Expression: [0 0 +quad.g 0 0 0]
     * Referenced by: '<S10>/Assuming that calib was done level!'
     */
    { 0.0, 0.0, 9.81, 0.0, 0.0, 0.0 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S10>/FIR_IMUaccel'
                                        */

    /*  Expression: estimParams.IMU.filter_accel.Coefficients
     * Referenced by: '<S10>/FIR_IMUaccel'
     */
    { 0.026407724923238066, 0.14053136276241623, 0.3330609123143457,
      0.3330609123143457, 0.14053136276241623, 0.026407724923238066 },

    /*  Expression: estimParams.IMU.filter_gyro_r_b
     * Referenced by: '<S10>/IIR_IMUgyro_r'
     */
    { 0.28212412246252067, 1.272539291716861, 2.4208439774454473,
      2.4208439774454487, 1.272539291716863, 0.28212412246252133 },

    /*  Expression: estimParams.IMU.filter_gyro_r_a
     * Referenced by: '<S10>/IIR_IMUgyro_r'
     */
    { 1.0, 2.2287149173647665, 2.5244618916938606, 1.5772531712757014,
      0.541022406829817, 0.079562396085500781 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S10>/IIR_IMUgyro_r'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S66>/Delay'
                                        */

    /*  Expression: pInitialization.M
     * Referenced by: '<S134>/KalmanGainM'
     */
    { 0.005756860081440762, 0.0, 0.0, 0.005756860081440762 },

    /*  Expression: estimParams.IMU.filter_gyro_r_b
     * Referenced by: '<S69>/IIRgyroz'
     */
    { 0.28212412246252067, 1.272539291716861, 2.4208439774454473,
      2.4208439774454487, 1.272539291716863, 0.28212412246252133 },

    /*  Expression: estimParams.IMU.filter_gyro_r_b
     * Referenced by: '<S69>/IIRgyroz'
     */
    { 0.28212412246252067, 1.272539291716861, 2.4208439774454473,
      2.4208439774454487, 1.272539291716863, 0.28212412246252133 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S69>/IIRgyroz'
                                        */
    200.0,                             /* Computed Parameter: TSamp_WtEt
                                        * Referenced by: '<S119>/TSamp'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S65>/Delay'
                                        */
    20.0,                              /* Expression: estimParams.pos.opticalFlowToVelocity_gain
                                        * Referenced by: '<S65>/opticalFlowToVelocity_gain'
                                        */
    -1.0,                              /* Expression: -1
                                        * Referenced by: '<S7>/invertzaxisGain'
                                        */
    0.0,                               /* Expression: -inf
                                        * Referenced by: '<S12>/SaturationSonar'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S7>/Delay2'
                                        */

    /*  Expression: estimParams.alt.filter_prs_b
     * Referenced by: '<S12>/pressureFilter_IIR'
     */
    { 0.007509257528603033, -0.022498139897706472, 0.014988905760749172,
      0.014988905760749172, -0.022498139897706455, 0.0075092575286030234 },

    /*  Expression: estimParams.alt.filter_prs_a
     * Referenced by: '<S12>/pressureFilter_IIR'
     */
    { 1.0, -4.89810443312637, 9.5974881329446688, -9.4036722433820046,
      4.60730099744654, -0.90301240709954322 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S12>/pressureFilter_IIR'
                                        */

    /*  Expression: estimParams.alt.filter_sonar_b
     * Referenced by: '<S12>/soonarFilter_IIR'
     */
    { 0.007509257528603033, -0.022498139897706472, 0.014988905760749172,
      0.014988905760749172, -0.022498139897706455, 0.0075092575286030234 },

    /*  Expression: estimParams.alt.filter_sonar_a
     * Referenced by: '<S12>/soonarFilter_IIR'
     */
    { 1.0, -4.89810443312637, 9.5974881329446688, -9.4036722433820046,
      4.60730099744654, -0.90301240709954322 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S12>/soonarFilter_IIR'
                                        */

    /*  Expression: pInitialization.M
     * Referenced by: '<S16>/KalmanGainM'
     */
    { 0.026241420641871072, 0.069776736071495274 },

    /*  Expression: [0 0 quad.g]
     * Referenced by: '<S7>/gravity'
     */
    { 0.0, 0.0, 9.81 },

    /*  Expression: pInitialization.C
     * Referenced by: '<S11>/C'
     */
    { 1.0, 0.0 },
    0.0,                               /* Expression: pInitialization.D
                                        * Referenced by: '<S11>/D'
                                        */

    /*  Expression: pInitialization.X0
     * Referenced by: '<S11>/X0'
     */
    { -0.046, 0.0 },

    /*  Expression: pInitialization.M
     * Referenced by: '<S74>/KalmanGainM'
     */
    { 0.1254656089860898, 0.0, 0.0, 0.1254656089860898 },

    /*  Expression: [0 0 -quad.g]
     * Referenced by: '<S67>/gravity'
     */
    { 0.0, 0.0, -9.81 },
    0.2,                               /* Expression: estimParams.pos.accelerationInput_gain
                                        * Referenced by: '<S67>/gainaccinput'
                                        */

    /*  Expression: pInitialization.C
     * Referenced by: '<S68>/C'
     */
    { 1.0, 0.0, 0.0, 1.0 },

    /*  Expression: pInitialization.D
     * Referenced by: '<S68>/D'
     */
    { 0.0, 0.0, 0.0, 0.0 },

    /*  Expression: pInitialization.X0
     * Referenced by: '<S68>/X0'
     */
    { 0.0, 0.0 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S3>/Delay1'
                                        */

    /*  Expression: pInitialization.C
     * Referenced by: '<S131>/C'
     */
    { 1.0, 0.0, 0.0, 1.0 },

    /*  Expression: pInitialization.D
     * Referenced by: '<S131>/D'
     */
    { 0.0, 0.0, 0.0, 0.0 },

    /*  Expression: pInitialization.X0
     * Referenced by: '<S131>/X0'
     */
    { 0.1, 0.0 },
    0.005,                             /* Computed Parameter: SimplyIntegrateVelocity_gainval
                                        * Referenced by: '<S66>/SimplyIntegrateVelocity'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S66>/SimplyIntegrateVelocity'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S66>/UseIPPosSwitch'
                                        */
    0.3,                               /* Expression: estimParams.alt.deltaSonarToCurrent_max
                                        * Referenced by: '<S7>/Bias'
                                        */
    -0.3,                              /* Expression: -estimParams.alt.deltaSonarToCurrent_max
                                        * Referenced by: '<S7>/Bias1'
                                        */

    /*  Expression: pInitialization.A
     * Referenced by: '<S11>/A'
     */
    { 1.0, 0.0, 0.005, 1.0 },

    /*  Expression: pInitialization.B
     * Referenced by: '<S11>/B'
     */
    { 0.0, 0.005 },

    /*  Expression: pInitialization.L
     * Referenced by: '<S16>/KalmanGainL'
     */
    { 0.026590304322228548, 0.069776736071495274 },

    /*  Expression: pInitialization.A
     * Referenced by: '<S68>/A'
     */
    { 1.0, 0.0, 0.0, 1.0 },

    /*  Expression: pInitialization.B
     * Referenced by: '<S68>/B'
     */
    { 0.005, 0.0, 0.0, 0.005 },

    /*  Expression: pInitialization.L
     * Referenced by: '<S74>/KalmanGainL'
     */
    { 0.1254656089860898, 0.0, 0.0, 0.1254656089860898 },

    /*  Expression: pInitialization.A
     * Referenced by: '<S131>/A'
     */
    { 1.0, 0.0, 0.0, 1.0 },

    /*  Expression: pInitialization.B
     * Referenced by: '<S131>/B'
     */
    { 0.005, 0.0, 0.0, 0.005 },

    /*  Expression: pInitialization.L
     * Referenced by: '<S134>/KalmanGainL'
     */
    { 0.005756860081440762, 0.0, 0.0, 0.005756860081440762 },
    1U,                                /* Computed Parameter: Delay_DelayLength
                                        * Referenced by: '<S66>/Delay'
                                        */
    1U,                                /* Computed Parameter: Delay_DelayLength_i
                                        * Referenced by: '<S65>/Delay'
                                        */
    1U,                                /* Computed Parameter: Delay2_DelayLength
                                        * Referenced by: '<S7>/Delay2'
                                        */
    1U,                                /* Computed Parameter: MemoryX_DelayLength
                                        * Referenced by: '<S11>/MemoryX'
                                        */
    1U,                                /* Computed Parameter: MemoryX_DelayLength_e
                                        * Referenced by: '<S68>/MemoryX'
                                        */
    1U,                                /* Computed Parameter: Delay1_DelayLength
                                        * Referenced by: '<S3>/Delay1'
                                        */
    1U,                                /* Computed Parameter: MemoryX_DelayLength_a
                                        * Referenced by: '<S131>/MemoryX'
                                        */

    /* Start of '<S1>/ControllerPID' */
    {
      0.3,                             /* Expression: 0.3
                                        * Referenced by: '<S2>/D_z'
                                        */
      0.8,                             /* Expression: 0.8
                                        * Referenced by: '<S2>/P_z'
                                        */

      /*  Expression: [0.1, -0.1]
       * Referenced by: '<S2>/D_xy'
       */
      { 0.1, -0.1 },
      3.0,                             /* Expression: 3
                                        * Referenced by: '<S2>/Saturation'
                                        */
      -3.0,                            /* Expression: -3
                                        * Referenced by: '<S2>/Saturation'
                                        */

      /*  Expression: [-0.24,0.24]
       * Referenced by: '<S2>/P_xy'
       */
      { -0.24, 0.24 },
      0.0,                             /* Expression: 0
                                        * Referenced by: '<S2>/Delay'
                                        */
      0.001,                           /* Expression: 0.001
                                        * Referenced by: '<S2>/antiWU_Gain'
                                        */
      0.004,                           /* Expression: 0.004
                                        * Referenced by: '<S2>/P_yaw'
                                        */
      0.0012,                          /* Expression: 0.3*0.004
                                        * Referenced by: '<S2>/D_yaw'
                                        */

      /*  Expression: [0.013;0.02]
       * Referenced by: '<S2>/P_pr'
       */
      { 0.013, 0.02 },
      0.005,                           /* Computed Parameter: DiscreteTimeIntegrator_gainval
                                        * Referenced by: '<S2>/Discrete-Time Integrator'
                                        */
      0.0,                             /* Expression: 0
                                        * Referenced by: '<S2>/Discrete-Time Integrator'
                                        */
      2.0,                             /* Expression: 2
                                        * Referenced by: '<S2>/Discrete-Time Integrator'
                                        */
      -2.0,                            /* Expression: -2
                                        * Referenced by: '<S2>/Discrete-Time Integrator'
                                        */
      0.01,                            /* Expression: 0.01
                                        * Referenced by: '<S2>/I_pr'
                                        */

      /*  Expression: [0.002;0.003]
       * Referenced by: '<S2>/D_pr'
       */
      { 0.002, 0.003 },
      10.0,                            /* Expression: 10
                                        * Referenced by: '<S6>/Saturation5'
                                        */

      /*  Expression: [1 -1 1 -1]
       * Referenced by: '<S6>/Motordirections1'
       */
      { 1.0, -1.0, 1.0, -1.0 },
      1U                               /* Computed Parameter: Delay_DelayLength
                                        * Referenced by: '<S2>/Delay'
                                        */
    }
    /* End of '<S1>/ControllerPID' */
  }
  /* End of '<Root>/Drone_Compensator' */
};                                     /* Modifiable parameters */

//-------------------
// END OF SIMULINK compensator block "Parameter definitions"
//-------------------


//-------------------
//SIMULINK compensator block "Input/Outputport Declarations" IO(1/3)
//-------------------
/*
 * Input/output port declarations from the SIMULINK compensator block go here.
 * If those were changed, copy the corresponding lines from ert_main.c from the autogenerated code here.
 * Note, that for updating input/output-ports there are code paragraphs to update: IO(1/3), IO(2/3), IO(3/3)
 */

static B_Drone_Compensator_T Drone_Compensator_B;/* Observable signals */
static DW_Drone_Compensator_T Drone_Compensator_DW;/* Observable states */

/* '<Root>/controlModePosVSOrient_flagin' */
static boolean_T Drone_Compensator_U_controlModePosVSOrient_flagin;

/* '<Root>/pos_refin' */
static real_T Drone_Compensator_U_pos_refin[3];

/* '<Root>/takeoff_flag' */
static boolean_T Drone_Compensator_U_takeoff_flag;

/* '<Root>/orient_refin' */
static real_T Drone_Compensator_U_orient_refin[3];

/* '<Root>/ddx' */
static real_T Drone_Compensator_U_ddx;

/* '<Root>/ddy' */
static real_T Drone_Compensator_U_ddy;

/* '<Root>/ddz' */
static real_T Drone_Compensator_U_ddz;

/* '<Root>/p' */
static real_T Drone_Compensator_U_p;

/* '<Root>/q' */
static real_T Drone_Compensator_U_q;

/* '<Root>/r' */
static real_T Drone_Compensator_U_r;

/* '<Root>/altitude_sonar' */
static real_T Drone_Compensator_U_altitude_sonar;

/* '<Root>/prs' */
static real_T Drone_Compensator_U_prs;

/* '<Root>/opticalFlow_datin' */
static real_T Drone_Compensator_U_opticalFlow_datin[3];

/* '<Root>/sensordataCalib_datin' */
static real_T Drone_Compensator_U_sensordataCalib_datin[7];

/* '<Root>/posVIS_datin' */
static real_T Drone_Compensator_U_posVIS_datin[4];

/* '<Root>/usePosVIS_flagin' */
static real_T Drone_Compensator_U_usePosVIS_flagin;

/* '<Root>/batteryStatus_datin' */
static real_T Drone_Compensator_U_batteryStatus_datin[2];

/* '<Root>/motors_refout' */
static real_T Drone_Compensator_Y_motors_refout[4];

/* '<Root>/X' */
static real_T Drone_Compensator_Y_X;

/* '<Root>/Y' */
static real_T Drone_Compensator_Y_Y;

/* '<Root>/Z' */
static real_T Drone_Compensator_Y_Z;

/* '<Root>/yaw' */
static real_T Drone_Compensator_Y_yaw;

/* '<Root>/pitch' */
static real_T Drone_Compensator_Y_pitch;

/* '<Root>/roll' */
static real_T Drone_Compensator_Y_roll;

/* '<Root>/dx' */
static real_T Drone_Compensator_Y_dx;

/* '<Root>/dy' */
static real_T Drone_Compensator_Y_dy;

/* '<Root>/dz' */
static real_T Drone_Compensator_Y_dz;

/* '<Root>/pb' */
static real_T Drone_Compensator_Y_pb;

/* '<Root>/qb' */
static real_T Drone_Compensator_Y_qb;

/* '<Root>/rb' */
static real_T Drone_Compensator_Y_rb;

/* '<Root>/controlModePosVSOrient_flagout' */
static boolean_T Drone_Compensator_Y_controlModePosVSOrient_flagout;

/* '<Root>/pose_refout' */
static real_T Drone_Compensator_Y_pose_refout[6];

/* '<Root>/ddxb' */
static real_T Drone_Compensator_Y_ddxb;

/* '<Root>/ddyb' */
static real_T Drone_Compensator_Y_ddyb;

/* '<Root>/ddzb' */
static real_T Drone_Compensator_Y_ddzb;

/* '<Root>/pa' */
static real_T Drone_Compensator_Y_pa;

/* '<Root>/qa' */
static real_T Drone_Compensator_Y_qa;

/* '<Root>/ra' */
static real_T Drone_Compensator_Y_ra;

/* '<Root>/altitude_sonarb' */
static real_T Drone_Compensator_Y_altitude_sonarb;

/* '<Root>/prsb' */
static real_T Drone_Compensator_Y_prsb;

/* '<Root>/opticalFlow_datout' */
static real_T Drone_Compensator_Y_opticalFlow_datout[3];

/* '<Root>/sensordataCalib_datout' */
static real_T Drone_Compensator_Y_sensordataCalib_datout[7];

/* '<Root>/posVIS_datout' */
static real_T Drone_Compensator_Y_posVIS_datout[4];

/* '<Root>/usePosVIS_flagout' */
static real_T Drone_Compensator_Y_usePosVIS_flagout;

/* '<Root>/batteryStatus_datout' */
static real_T Drone_Compensator_Y_batteryStatus_datout[2];

/* '<Root>/takeoff_flagout' */
static boolean_T Drone_Compensator_Y_takeoff_flagout;

//-------------------
//END OF SIMULINK compensator block "Input/Outputport Declarations" IO(1/3)
//-------------------

//steps the SIMULINK compensator block model one step
void rt_OneStep(RT_MODEL_Drone_Compensator_T *const Drone_Compensator_M);
void rt_OneStep(RT_MODEL_Drone_Compensator_T *const Drone_Compensator_M)
{
    static boolean_T OverrunFlag = false;

    /* Disable interrupts here */

    /* Check for overrun */
    if(OverrunFlag)
    {
        rtmSetErrorStatus(Drone_Compensator_M, "Overrun");
        return;
    }

    OverrunFlag = true;

    /* Save FPU context here (if necessary) */
    /* Re-enable timer or interrupt here */
    /* Set model inputs here */

    /* Step the model */
    // (IO(2/3): If input-output-ports of the SIMULINK controller block changed, update these lines with the corresponding lines from ert_main.c)
    /* Step the model */
  Drone_Compensator_step(Drone_Compensator_M,
    Drone_Compensator_U_controlModePosVSOrient_flagin,
    Drone_Compensator_U_pos_refin, Drone_Compensator_U_takeoff_flag,
    Drone_Compensator_U_orient_refin, Drone_Compensator_U_ddx,
    Drone_Compensator_U_ddy, Drone_Compensator_U_ddz, Drone_Compensator_U_p,
    Drone_Compensator_U_q, Drone_Compensator_U_r,
    Drone_Compensator_U_altitude_sonar, Drone_Compensator_U_prs,
    Drone_Compensator_U_opticalFlow_datin,
    Drone_Compensator_U_sensordataCalib_datin, Drone_Compensator_U_posVIS_datin,
    Drone_Compensator_U_usePosVIS_flagin,
    Drone_Compensator_U_batteryStatus_datin, Drone_Compensator_Y_motors_refout,
    &Drone_Compensator_Y_X, &Drone_Compensator_Y_Y, &Drone_Compensator_Y_Z,
    &Drone_Compensator_Y_yaw, &Drone_Compensator_Y_pitch,
    &Drone_Compensator_Y_roll, &Drone_Compensator_Y_dx, &Drone_Compensator_Y_dy,
    &Drone_Compensator_Y_dz, &Drone_Compensator_Y_pb, &Drone_Compensator_Y_qb,
    &Drone_Compensator_Y_rb, &Drone_Compensator_Y_controlModePosVSOrient_flagout,
    Drone_Compensator_Y_pose_refout, &Drone_Compensator_Y_ddxb,
    &Drone_Compensator_Y_ddyb, &Drone_Compensator_Y_ddzb,
    &Drone_Compensator_Y_pa, &Drone_Compensator_Y_qa, &Drone_Compensator_Y_ra,
    &Drone_Compensator_Y_altitude_sonarb, &Drone_Compensator_Y_prsb,
    Drone_Compensator_Y_opticalFlow_datout,
    Drone_Compensator_Y_sensordataCalib_datout,
    Drone_Compensator_Y_posVIS_datout, &Drone_Compensator_Y_usePosVIS_flagout,
    Drone_Compensator_Y_batteryStatus_datout,
    &Drone_Compensator_Y_takeoff_flagout);
    //-------------------
    //-------------------


    /* Get model outputs here */

    /* Indicate task complete */
    OverrunFlag = false;

    /* Disable interrupts here */
    /* Restore FPU context here (if necessary) */
    /* Enable interrupts here */
}


//--------------------
// RSEDU_control
//--------------------
/*
 * The function RSEDU_control is called at 200Hz to generate reference motor commands based on sensor values
 * @input hal_sensors_data Structure containing sensors current values
 * @output hal_sensors_cmd Structure containing commands to send to motors and LEDs
 */
void RSEDU_control(HAL_acquisition_t* hal_sensors_data, HAL_command_t* hal_sensors_cmd)
{
    //flight phases
    static int run_flag = 1;

    //process control
    static int counter = 0;
    static int counter_noOF = 0;

    static float MAX_ACCELL 	= 6.0;
    static float MAX_DELTADXY 	= 6.0;
    static float MAX_RANGE 		= 10.0;
    static float MIN_BATTTAKEOFF 	= 50.0;
    static float MIN_BATT		= 30.0;
    static int MAX_noOF 		= 50; //maximum acceptable numbers of cycles without optical flow

    //powe/usr input    
    double powerGain = 0;
    static double powerGain_paramsFile = 0.1;


    //data handling
    static double sensorCal[7];
    static double battLevelAvg;
    static float of_data[5];
    float vis_data[4];

    //float ofDefined;
    static bool pressureSensorOk = false;
    static float ofQuality;

    //communication
    static char serverIP[16];
    strncpy(serverIP, "192.168.1.2", 16);
    static int sockfd = 0;
    static char recvBuff[100];
    static struct sockaddr_in serv_addr;

    int pitch_ref_buff, roll_ref_buff, yaw_ref_buff, alt_ref_buff;

    static int of_fifo, vis_fifo;



    /*-------------------------
     * PROGRAM
     -------------------------*/

    //ptiming - declare and start
    //------------
    long long start;
    static FILE *ptfile;
    ptimer_start(FEAT_TIME, counter, &(start));
    //------------


    // Create easier aliases

    HAL_acquisition_t* in = hal_sensors_data;
    HAL_command_t    * out = hal_sensors_cmd;

    //ABORT FLIGHT and exit if run_flag 0
    if(run_flag == 0)
    {
        if(counter > calibCycles)
        {
            printf("Saving logged data after %i cycles... \n", counter);
            rt_StopDataLogging(MATFILE, Drone_Compensator_M->rtwLogInfo);
        }

        if(FEAT_OF_ACTIVE)
        {
            close(of_fifo);
        }

        if(FEAT_TIME)
        {
            fclose(ptfile);
        };


        printf("Saving logged data... DONE \n");
        printf("Good night! \n");
        out->motors_speed[0] = 0;
        out->motors_speed[1] = 0;
        out->motors_speed[2] = 0;
        out->motors_speed[3] = 0;
        out->command = BLDC_CMD_STOP;
        usleep(100);
        exit(0);
    }


    //Process Control
    counter++;


    //Flight Stages s 0-4
    //--------------

    //s0: Initialize (server connection, get user settings)

    if(counter == 1)
    {
        printf("\nBattery output voltage: %5.2f V - %0d percents\n", in->HAL_vbat_SI.vbat_V, (int)in->HAL_vbat_SI.vbat_percentage);
        printf("used: %d, users: %d, gyrotemp %f, acctemp %f, presstmp %f \n", (int)in->used, (int)in->count_user, in->HAL_gyro_SI.temperature, in->HAL_acc_SI.temperature, in->HAL_pressure_SI.temperature);


        //read parameters

        FILE *paramFile;
        paramFile = fopen("/data/edu/params/paramsEDU.dat", "r");
        if(paramFile == NULL)
        {
            printf("ParamsEDU.dat parameter file not found, using default! \n");
        }

        else
        {
            char tmpbuff[50];
            char tmpstr1[16];
            char tmpstr2[16];
            while(!feof(paramFile))
            {
                if(fgets(tmpbuff, 50, paramFile))
                {
                    sscanf(tmpbuff, "%15s : %15[^;];", tmpstr1, tmpstr2);

                    if(!strcmp(tmpstr1, "FEAT_OF_ACTIVE"))
                    {
                        FEAT_OF_ACTIVE = atoi(tmpstr2);
                    }
                    else if(!strcmp(tmpstr1, "FEAT_POSVIS_RUN"))
                    {
                        FEAT_POSVIS_RUN = atoi(tmpstr2);
                    }
                    else if(!strcmp(tmpstr1, "POWERGAIN"))
                    {
                        powerGain_paramsFile = atoi(tmpstr2) / 100.0;
                    }
                    else if(!strcmp(tmpstr1, "FEAT_POSVIS_USE"))
                    {
                        FEAT_POSVIS_USE = atoi(tmpstr2);
                    }
                    else if(!strcmp(tmpstr1, "FEAT_NOLOOK"))
                    {
                        FEAT_NOLOOK = atoi(tmpstr2);
                    }
                    else if(!strcmp(tmpstr1, "FEAT_IMSAVE"))
                    {
                        FEAT_IMSAVE = atoi(tmpstr2);
                    }
                    else if(!strcmp(tmpstr1, "FEAT_TIME"))
                    {
                        FEAT_TIME = atoi(tmpstr2);
                    }
                    else if(!strcmp(tmpstr1, "FEAT_NOSAFETY"))
                    {
                        FEAT_NOSAFETY = atoi(tmpstr2);
                    }
                    else if(!strcmp(tmpstr1, "IP"))
                    {
                        memcpy(serverIP, tmpstr2, sizeof(tmpstr2));
                    };

                }
            }
            fclose(paramFile);
        }

        printf("\nSettings:\n -----\n FEAT_TIME: %d \n FEAT_OF_ACTIVE: %d \n FEAT_POSVIS_RUN: %d \n FEAT_POSVIS_USE: %d \n FEAT_NOLOOK: %d \n FEAT_IMSAVE: %d \n FEAT_NOSAFETY: %d \n -----\n", FEAT_TIME, FEAT_OF_ACTIVE, FEAT_POSVIS_RUN, FEAT_POSVIS_USE, FEAT_NOLOOK, FEAT_IMSAVE, FEAT_NOSAFETY);


        //ptiming - init file
        //------------
        ptimer_init(FEAT_TIME, __func__, &(ptfile), &(run_flag));
        //------------



        //init reference Server Communication
        //-----
        printf("Waiting for connection to reference value server... \n");

        if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        {
            printf("\n ERROR : Could not create socket \n");
            exit(0);
        }

        memset(&serv_addr, '0', sizeof(serv_addr));

        serv_addr.sin_family = AF_INET;
        serv_addr.sin_port = htons(12345);

        if(inet_pton(AF_INET, serverIP, &serv_addr.sin_addr) <= 0)
        {
            printf("ERROR inet_pton error occured (connection to reference value server) \n");
            exit(0);
        }

        if(connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
        {
            printf("ERROR Connection to reference value server failed \n");            
            exit(0);
        }
        else
        {
            printf("Connected to reference value server! \n");
        }



        //Powergain user prompt
        //-----
        /*
	int power_usrinpt;
        printf("Power-Gain in %% ? \n");
        scanf("%i", &power_usrinpt);
        powerGain_paramsFile = power_usrinpt/100.0;
        if (powerGain_paramsFile>1.0) {powerGain_paramsFile=1.0;};
        printf ("Power-Gain %f \n",powerGain_paramsFile);
        */

    }

    //Initialize inter-thread communication
    else if(counter == 2)
    {

        //Initialize communication with optical flow thread
        //-------
        printf("Waiting for optical flow connection...\n");
        usleep(100);
        of_fifo = open("/tmp/of_fifo", O_RDONLY); //O_NONBLOCK O_RDONLY
        fcntl(of_fifo, F_SETFL, fcntl(of_fifo, F_GETFL) | O_NONBLOCK);

        if(FEAT_OF_ACTIVE)
        {
            read(of_fifo, (float*)(&of_data), sizeof(of_data));
            if(of_fifo < 0)
            {
                printf("WARNING optical flow might not be running, %d!\n\n", of_fifo);
            }
            else
            {
                printf("Got optical flow connection, %d!\n", of_fifo);
            }

        }
        else
        {
            printf("Optical Flow deactivated! \n");
        }


        //Initialize communication with image processing thread
        //-------
        printf("Waiting for image processing connection...\n");
        usleep(100);
        vis_fifo = open("/tmp/vis_fifo", O_RDONLY); //O_NONBLOCK O_RDONLY
        fcntl(vis_fifo, F_SETFL, fcntl(vis_fifo, F_GETFL) | O_NONBLOCK);

        if(FEAT_POSVIS_RUN)
        {
            read(vis_fifo, (float*)(&vis_data), sizeof(vis_data));
            if(vis_fifo < 0)
            {
                printf("WARNING image processing might not be running, %d!\n", vis_fifo);
            }
            else
            {
                printf("Got image processing connection, %d !\n", vis_fifo);
            }
        }
        else
        {
            printf("POSVIS computations deactivated! \n");
        };


        //init sensor calibration measurements
        //-----
        sensorCal[0] = in->HAL_acc_SI.x;
        sensorCal[1] = in->HAL_acc_SI.y;
        sensorCal[2] = in->HAL_acc_SI.z;
        sensorCal[3] = in->HAL_gyro_SI.x;
        sensorCal[4] = in->HAL_gyro_SI.y;
        sensorCal[5] = in->HAL_gyro_SI.z;
        sensorCal[6] = in->HAL_pressure_SI.pressure;

        battLevelAvg = (double)((int)in->HAL_vbat_SI.vbat_percentage);

        //Activate motors
        out->command = BLDC_CMD_START;
    }


    //s1: Record calibration data
    else if(counter < calibCycles)
    {
	int counterCalib = counter - 2; if (counterCalib<=0) printf("error in counter %d for Calibration!\n",counterCalib);
        sensorCal[0] = sensorCal[0] * (counterCalib - 1) / counterCalib + in->HAL_acc_SI.x / counterCalib;
        sensorCal[1] = sensorCal[1] * (counterCalib - 1) / counterCalib + in->HAL_acc_SI.y / counterCalib;
        sensorCal[2] = sensorCal[2] * (counterCalib - 1) / counterCalib + in->HAL_acc_SI.z / counterCalib;
        sensorCal[3] = sensorCal[3] * (counterCalib - 1) / counterCalib + in->HAL_gyro_SI.x / counterCalib;
        sensorCal[4] = sensorCal[4] * (counterCalib - 1) / counterCalib + in->HAL_gyro_SI.y / counterCalib;
        sensorCal[5] = sensorCal[5] * (counterCalib - 1) / counterCalib + in->HAL_gyro_SI.z / counterCalib;
        sensorCal[6] = sensorCal[6] * (counterCalib - 1) / counterCalib + in->HAL_pressure_SI.pressure / counterCalib;

        if(in->HAL_pressure_SI.pressure != 0) pressureSensorOk = true;

        battLevelAvg = battLevelAvg * (counterCalib - 1) / counterCalib + (double)((int)in->HAL_vbat_SI.vbat_percentage) / counterCalib;

        //keep fifos empty
        if(FEAT_OF_ACTIVE)  read(of_fifo, (float*)(&of_data), sizeof(of_data));
        if(FEAT_POSVIS_RUN) read(vis_fifo, (float*)(&vis_data), sizeof(vis_data));


        //Power motors with 0 velocity
        out->motors_speed[0] = 0;
        out->motors_speed[1] = 0;
        out->motors_speed[2] = 0;
        out->motors_speed[3] = 0;
        out->command = BLDC_CMD_STOP;
        return;
    }

    //s2: Initialize dynamic model for control
    else if(counter == calibCycles)
    {
        printf("Batterylevel: %f\n", battLevelAvg);
        printf("Sensorcal: %f :: %f :: %f :: %f :: %f :: %f :: %f \n", sensorCal[0], sensorCal[1], sensorCal[2], sensorCal[3], sensorCal[4], sensorCal[5], sensorCal[6]);

        //Stop if angled take-off
        if((!FEAT_NOSAFETY) && fabs(9.81 + sensorCal[2]) > 0.7)
        {
            run_flag = 0;
            printf("ERROR: Please take off from a level surface! \n");
            out->motors_speed[0] = 0;
            out->motors_speed[1] = 0;
            out->motors_speed[2] = 0;
            out->motors_speed[3] = 0;
            out->command = BLDC_CMD_STOP;
            return;
        }

        if(!pressureSensorOk)
        {
            run_flag = 0;
            printf("ERROR: Pressure sensor appears damaged! \n");
            out->motors_speed[0] = 0;
            out->motors_speed[1] = 0;
            out->motors_speed[2] = 0;
            out->motors_speed[3] = 0;
            out->command = BLDC_CMD_STOP;
            return;
        }



        //Init SIMULINK compensator model
        //(IO(3/3): If input-output-ports of the SIMULINK controller block changed, update these lines with the corresponding lines from ert_main.c)
        //----------

        /* Pack model data into RTM */
	  Drone_Compensator_M->ModelData.defaultParam = &Drone_Compensator_P;
	  Drone_Compensator_M->ModelData.blockIO = &Drone_Compensator_B;
	  Drone_Compensator_M->ModelData.dwork = &Drone_Compensator_DW;

        /* Initialize model */
	  Drone_Compensator_initialize(Drone_Compensator_M,
	    &Drone_Compensator_U_controlModePosVSOrient_flagin,
	    Drone_Compensator_U_pos_refin, &Drone_Compensator_U_takeoff_flag,
	    Drone_Compensator_U_orient_refin, &Drone_Compensator_U_ddx,
	    &Drone_Compensator_U_ddy, &Drone_Compensator_U_ddz, &Drone_Compensator_U_p,
	    &Drone_Compensator_U_q, &Drone_Compensator_U_r,
	    &Drone_Compensator_U_altitude_sonar, &Drone_Compensator_U_prs,
	    Drone_Compensator_U_opticalFlow_datin,
	    Drone_Compensator_U_sensordataCalib_datin, Drone_Compensator_U_posVIS_datin,
	    &Drone_Compensator_U_usePosVIS_flagin,
	    Drone_Compensator_U_batteryStatus_datin, Drone_Compensator_Y_motors_refout,
	    &Drone_Compensator_Y_X, &Drone_Compensator_Y_Y, &Drone_Compensator_Y_Z,
	    &Drone_Compensator_Y_yaw, &Drone_Compensator_Y_pitch,
	    &Drone_Compensator_Y_roll, &Drone_Compensator_Y_dx, &Drone_Compensator_Y_dy,
	    &Drone_Compensator_Y_dz, &Drone_Compensator_Y_pb, &Drone_Compensator_Y_qb,
	    &Drone_Compensator_Y_rb, &Drone_Compensator_Y_controlModePosVSOrient_flagout,
	    Drone_Compensator_Y_pose_refout, &Drone_Compensator_Y_ddxb,
	    &Drone_Compensator_Y_ddyb, &Drone_Compensator_Y_ddzb,
	    &Drone_Compensator_Y_pa, &Drone_Compensator_Y_qa, &Drone_Compensator_Y_ra,
	    &Drone_Compensator_Y_altitude_sonarb, &Drone_Compensator_Y_prsb,
	    Drone_Compensator_Y_opticalFlow_datout,
	    Drone_Compensator_Y_sensordataCalib_datout,
	    Drone_Compensator_Y_posVIS_datout, &Drone_Compensator_Y_usePosVIS_flagout,
	    Drone_Compensator_Y_batteryStatus_datout,
	    &Drone_Compensator_Y_takeoff_flagout);

        //-------------------
        //-------------------

        //init optical flow and vision outputport in case that functionality is deactivated
        Drone_Compensator_U_posVIS_datin[0] = NO_VIS_X;
        Drone_Compensator_U_posVIS_datin[1] = 0.0;
        Drone_Compensator_U_posVIS_datin[2] = 0.0;
        Drone_Compensator_U_posVIS_datin[3] = 0.0;

        //check if image processing up and running
        if((FEAT_POSVIS_RUN) && (vis_fifo < 0))
        {
            vis_fifo = open("/tmp/vis_fifo", O_RDONLY); //O_NONBLOCK O_RDONLY
            fcntl(vis_fifo, F_SETFL, fcntl(vis_fifo, F_GETFL) | O_NONBLOCK);
            if(vis_fifo < 0) printf("WARNING image processing not connected!\n");
        }

        //check if optical flow up and running
        if((FEAT_OF_ACTIVE) && (of_fifo < 0))
        {
            of_fifo = open("/tmp/of_fifo", O_RDONLY); //O_NONBLOCK O_RDONLY
            fcntl(of_fifo, F_SETFL, fcntl(of_fifo, F_GETFL) | O_NONBLOCK);
            if(of_fifo < 0) printf("ERROR optical flow not running!\n");
            run_flag = 0;
        }

        //input sensor biases into model
        Drone_Compensator_U_sensordataCalib_datin[0] = sensorCal[0];
        Drone_Compensator_U_sensordataCalib_datin[1] = sensorCal[1];
        Drone_Compensator_U_sensordataCalib_datin[2] = sensorCal[2];
        Drone_Compensator_U_sensordataCalib_datin[3] = sensorCal[3];
        Drone_Compensator_U_sensordataCalib_datin[4] = sensorCal[4];
        Drone_Compensator_U_sensordataCalib_datin[5] = sensorCal[5];
        Drone_Compensator_U_sensordataCalib_datin[6] = sensorCal[6];

        //Display beginning of relevant data output on screen
        //printf("Data_block_start\n");

        //Power motors, velocity 0
        out->command = BLDC_CMD_RUN;

    }

    //s3: Fly
    else if(counter <= onCycles)
    {

        //Tune settings to flight mode
        //----------

        //3.1 take off-setting
        if(counter < calibCycles + takeoffCycles)
        {
            powerGain = powerGain_paramsFile;
	    Drone_Compensator_U_takeoff_flag = 1;  //enables take-off procedure, disables altitude-control
            Drone_Compensator_U_pos_refin[2] = -1.1;
	    

            //React to possible low battery
            if((Drone_Compensator_U_batteryStatus_datin[1] < MIN_BATTTAKEOFF) && (Drone_Compensator_U_batteryStatus_datin[1] > 0.1))
            {
                run_flag = 0;
                printf("Flight aborted due to low voltage (%f %%): shutting down motors now, charge battery!\n", Drone_Compensator_U_batteryStatus_datin[1]);
                out->motors_speed[0] = 0;
                out->motors_speed[1] = 0;
                out->motors_speed[2] = 0;
                out->motors_speed[3] = 0;
                out->command = BLDC_CMD_STOP;
                return;
            }
        }

        //3.2 transition to actual flight: enable altitude-control setting
        else if(counter == calibCycles + takeoffCycles)
        {
	    Drone_Compensator_U_takeoff_flag = 0;  //disable take-off procedure, disables altitude-control	
            Drone_Compensator_U_pos_refin[2] = -1.1;
        }
        //3.3 actual flight setting
        else if(counter < onCycles)
        {
            powerGain = powerGain_paramsFile;

            //Read from reference value server
            fcntl(sockfd, F_SETFL, O_NONBLOCK);
            memset(recvBuff, '\0', sizeof(recvBuff));
            recv(sockfd, recvBuff, sizeof(recvBuff), O_NONBLOCK);


            //Input to Model: reference values

            if((recvBuff[0]) != '\0')
            {
                sscanf(recvBuff, "%i %i %i %i %i", &run_flag, &pitch_ref_buff, &roll_ref_buff, &yaw_ref_buff, &alt_ref_buff);
                Drone_Compensator_U_orient_refin[0] = (double)((yaw_ref_buff - 10000) / 1000.0);
                Drone_Compensator_U_orient_refin[1] = (double)((pitch_ref_buff - 10000) / 1000.0);
                Drone_Compensator_U_orient_refin[2] = (double)((roll_ref_buff - 10000) / 1000.0);
                if(((double)(alt_ref_buff / 100.0)) >= -4.0)
                {
                    Drone_Compensator_U_pos_refin[2]    = (double)(alt_ref_buff / 100.0);
                }
            }

            if((Drone_Compensator_U_orient_refin[1] == 0.0) && (Drone_Compensator_U_orient_refin[2] == 0.0))
                //control position + velocity if no specific reference attitude given (yaw angle ok)
                Drone_Compensator_U_controlModePosVSOrient_flagin = 1; //1 ; 1 position reference, 0 angle reference
            else
                //angle control
                Drone_Compensator_U_controlModePosVSOrient_flagin = 0; //0 ; 1 position reference, 0 angle reference


            //use of position estimate from vision
            Drone_Compensator_U_usePosVIS_flagin = FEAT_POSVIS_USE;

            //React to possible Flight abort request
            if(run_flag == 0)
            {
                printf("Flight abort request: shutting down motors now\n");
                out->motors_speed[0] = 0;
                out->motors_speed[1] = 0;
                out->motors_speed[2] = 0;
                out->motors_speed[3] = 0;
                out->command = BLDC_CMD_STOP;
                return;
            }

        }

        //3.4 init to stop flight (because of end of flight duration)
        else
        {
            powerGain = 0;
        };




        //Actual flight control
        //---------------------

        //safety abort for high accelerations or position
        bool crash_detected;
	//NOSAFETY  disabled and after takeoff-cycles
        if( (!FEAT_NOSAFETY) && (counter>(calibCycles + takeoffCycles)))
          crash_detected = (fabs(in->HAL_acc_SI.x) > MAX_ACCELL) || (fabs(in->HAL_acc_SI.y) > MAX_ACCELL) || (in->HAL_acc_SI.z > 0);
	//If either NOSAFETY enabled or during takeoff, allow greater accelerations without shutting down
        else
          crash_detected = (fabs(in->HAL_acc_SI.x) > MAX_ACCELL * 3) || (fabs(in->HAL_acc_SI.y) > MAX_ACCELL * 3);


        bool out_of_range = (fabs(Drone_Compensator_Y_X) > MAX_RANGE) || (fabs(Drone_Compensator_Y_Y) > MAX_RANGE);

        bool battery_low = (Drone_Compensator_U_batteryStatus_datin[1] < MIN_BATT) && (Drone_Compensator_U_batteryStatus_datin[1] > 1.0);

        // log any exit reasons
        if(crash_detected) printf("Flight crash detected (accelerometer): shutting down motors now\n");
        if(out_of_range)   printf("Drone out of range: shutting down motors now\n");
        if(battery_low)    printf("Flight aborted due to low voltage (%f %%): shutting down motors now, charge battery!\n", Drone_Compensator_U_batteryStatus_datin[1]);

        // and stop the drone
        if(crash_detected || battery_low || out_of_range) {
          run_flag = 0;
          out->motors_speed[0] = 0;
          out->motors_speed[1] = 0;
          out->motors_speed[2] = 0;
          out->motors_speed[3] = 0;
          out->command = BLDC_CMD_STOP;
          return;
        }

        //Input to Model: optical flow computations (setup as zero-order hold: no updates on static var when nothing new in fifo)
        if((FEAT_OF_ACTIVE) && (of_fifo > 0))
        {
            //usleep(100);
            //read(of_fifo,(float*)(&of_data),sizeof(of_data));
            //close(of_fifo);

            if((read(of_fifo, (float*)(&of_data), sizeof(of_data)) > 0) && ((of_data[0] != 0.0) || (of_data[1] != 0.0)))
            {
                ofQuality = of_data[3];
                //ofDefined = of_data[4];
                if(ofQuality > 0)
                {
                    counter_noOF = 0;
                    Drone_Compensator_U_opticalFlow_datin[0] = (double)of_data[0];
                    Drone_Compensator_U_opticalFlow_datin[1] = (double)of_data[1];
                    Drone_Compensator_U_opticalFlow_datin[2] = (double)of_data[2];
                    //printf("of: %f %f %f \n",of_data[0],of_data[1],of_data[2]);
                }
            }
            else
            {
                if(counter > (calibCycles + takeoffCycles))
                {
                    counter_noOF += 1;

                    if(counter_noOF >= MAX_noOF)
                    {
                        run_flag = 0;
                        printf("Problem with optical flow, there has been no flow for %d cycles in cycle %d: shutting down motors now\n", counter_noOF, counter);
                        out->motors_speed[0] = 0;
                        out->motors_speed[1] = 0;
                        out->motors_speed[2] = 0;
                        out->motors_speed[3] = 0;
                        out->command = BLDC_CMD_STOP;
                        return;
                    }
                }


            };

        }

        //safety abort for high mismatch OF vs state velocities
        if(ofQuality > 0 &&
            (counter > (calibCycles + takeoffCycles))
            &&
            (
                ((fabs(of_data[0]) > 0.01) && (fabs(20 * of_data[0] - Drone_Compensator_Y_dx) > MAX_DELTADXY))
                || ((fabs(of_data[1]) > 0.01) && (fabs(20 * of_data[1] - Drone_Compensator_Y_dy) > MAX_DELTADXY))
            )

        )
        {
            run_flag = 0;
            printf("Flight crash about to happen, mismatch optical flow (%f, %f) and state estimate (%f, %f): shutting down motors now\n",
              20 * of_data[0],
              20 * of_data[1],
              Drone_Compensator_Y_dx,
              Drone_Compensator_Y_dy);
            out->motors_speed[0] = 0;
            out->motors_speed[1] = 0;
            out->motors_speed[2] = 0;
            out->motors_speed[3] = 0;
            out->command = BLDC_CMD_STOP;
            return;
        }

        //Input to Model: image processing computations (DONOT setup as zero-order hold (pos_x -99.0 when no position available))
        if((FEAT_POSVIS_RUN) && (vis_fifo > 0))
        {

            if((read(vis_fifo, (float*)(&vis_data), sizeof(vis_data)) > 0) && ((vis_data[0] != 0.0) || (vis_data[1]) || (vis_data[3])))
            {
                Drone_Compensator_U_posVIS_datin[0] = (double)vis_data[0];
                Drone_Compensator_U_posVIS_datin[1] = (double)vis_data[1];
                Drone_Compensator_U_posVIS_datin[2] = (double)vis_data[2];
                Drone_Compensator_U_posVIS_datin[3] = (double)vis_data[3];

            }
            else
            {
                Drone_Compensator_U_posVIS_datin[0] = NO_VIS_X;
                Drone_Compensator_U_posVIS_datin[1] = 0.0;
                Drone_Compensator_U_posVIS_datin[2] = 0.0;
                Drone_Compensator_U_posVIS_datin[3] = 0.0;
            }

        }

        //Input to Model: sensor signals
        Drone_Compensator_U_ddx 	= in->HAL_acc_SI.x;
        Drone_Compensator_U_ddy 	= in->HAL_acc_SI.y;
        Drone_Compensator_U_ddz 	= in->HAL_acc_SI.z;
        Drone_Compensator_U_p 	= in->HAL_gyro_SI.x;
        Drone_Compensator_U_q 	= in->HAL_gyro_SI.y;
        Drone_Compensator_U_r		= in->HAL_gyro_SI.z;
        Drone_Compensator_U_altitude_sonar	= in->HAL_ultrasound_SI.altitude;
        Drone_Compensator_U_prs 	= in->HAL_pressure_SI.pressure;

        Drone_Compensator_U_batteryStatus_datin[0] = in->HAL_vbat_SI.vbat_V;
        Drone_Compensator_U_batteryStatus_datin[1] = (double)((int)in->HAL_vbat_SI.vbat_percentage);

        // compute control commands
        const char* error = rtmGetErrorStatus(Drone_Compensator_M);
        if(!error)
        {
            rt_OneStep(Drone_Compensator_M);
        }
        else
        {
            run_flag = 0;
            printf("ERROR: Error from simulink model @ counter=%i !\n\t%s", counter, error);
            out->motors_speed[0] = 0;
            out->motors_speed[1] = 0;
            out->motors_speed[2] = 0;
            out->motors_speed[3] = 0;
            out->command = BLDC_CMD_STOP;
            return;
        }

        //power engines
        if(counter < onCycles)
        {
            out->command = BLDC_CMD_RUN;
        }
        else
        {
            out->command = BLDC_CMD_STOP;
            return;
        };


        // update motor commands with control commands
        out->motors_speed[0] = (int)(powerGain * (fabs(Drone_Compensator_Y_motors_refout[0])));
        out->motors_speed[1] = (int)(powerGain * (fabs(Drone_Compensator_Y_motors_refout[1])));
        out->motors_speed[2] = (int)(powerGain * (fabs(Drone_Compensator_Y_motors_refout[2])));
        out->motors_speed[3] = (int)(powerGain * (fabs(Drone_Compensator_Y_motors_refout[3])));
        usleep(100);
        //printf("motorcmd: %d\n",out->motors_speed[0]);

    }

    //s4.0 End flight: log data and close program

    else //counter=durTest+1
    {
        /* Matfile logging save*/
        printf("Saving logged data at end of flight... \n");
        rt_StopDataLogging(MATFILE, Drone_Compensator_M->rtwLogInfo);
        if(FEAT_OF_ACTIVE)
        {
            close(of_fifo);
        }
        printf("Saving logged data... DONE \n");

        if(FEAT_TIME)
        {
            fclose(ptfile);
        }


        exit(0);
    }


    usleep(200);


    //ptiming - store
    //----------
    ptimer_stopstore(FEAT_TIME, counter, start, ptfile);
    //----------

}
